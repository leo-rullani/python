<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Hinweise zu Python</title>
</head>

<body>
    <h1>Hinweise zu Python</h1>

    <section>
        <h2>1. Variablen</h2>
        <ul>
            <li>Variablen speichern Werte. Zuweisung erfolgt mit <code>=</code>.</li>
            <li>Beispiel: <code>name = "Anna"</code> oder <code>age = 25</code>.</li>
            <li>Mehrere Zuweisungen mÃ¶glich: <code>name, age = "Lisa", 30</code>.</li>
            <li>Werte tauschen: <code>name, age = age, name</code>.</li>
            <li>Variablennamen dÃ¼rfen nicht mit Zahlen beginnen, keine Sonderzeichen oder Keywords.</li>
            <li>GroÃŸ-/Kleinschreibung ist relevant: <code>name â‰  Name</code>.</li>
            <li>Vermeide â€Magic Numbersâ€œ â€“ nutze stattdessen Variablen mit Bedeutung.</li>
        </ul>
    </section>

    <section>
        <h2>2. Datentypen</h2>
        <ul>
            <li>Python erkennt Datentypen automatisch (z.â€¯B. <code>str</code>, <code>int</code>, <code>float</code>,
                <code>bool</code>).</li>
            <li>Mit <code>type(var)</code> kannst du den Typ prÃ¼fen.</li>
            <li>Umwandlungen:
                <ul>
                    <li><code>str(25)</code> â†’ "25"</li>
                    <li><code>int("27")</code> â†’ 27</li>
                    <li><code>float("2.4")</code> â†’ 2.4</li>
                    <li><code>bool("")</code> â†’ False, <code>bool("abc")</code> â†’ True</li>
                </ul>
            </li>
            <li>Fehler bei ungÃ¼ltiger Umwandlung: z.â€¯B. <code>int("27 Jahre")</code> â†’ <code>ValueError</code>.</li>
            <li>0, 0.0, "" gelten als <code>False</code>, alle anderen Werte als <code>True</code>.</li>
        </ul>
    </section>

    <section>
        <h2>3. Umgebungsvariablen</h2>
        <ul>
            <li>Systemvariablen wie <code>PATH</code> oder <code>USER</code>.</li>
            <li>Zugriff in Python Ã¼ber <code>os.environ["NAME"]</code>.</li>
            <li><code>python-dotenv</code> ermÃ¶glicht das Einlesen einer <code>.env</code>-Datei.</li>
            <li><code>.env</code>-Datei enthÃ¤lt Key-Value-Paare, z.â€¯B. <code>USER_NAME=leo</code>.</li>
            <li><code>.env</code> gehÃ¶rt in die <code>.gitignore</code>.</li>
        </ul>
    </section>

    <section>
        <h2>4. Strings definieren</h2>
        <ul>
            <li>Strings mit <code>"Text"</code> oder <code>'Text'</code> definieren.</li>
            <li>Dreifache AnfÃ¼hrungszeichen <code>""" """</code> fÃ¼r mehrzeilige Strings.</li>
            <li>Empfehlung:
                <ul>
                    <li>Ein Zeichen: <code>'A'</code></li>
                    <li>Mehrere Zeichen: <code>"Hallo"</code></li>
                    <li>Leerer String: <code>""</code></li>
                </ul>
            </li>
            <li>Mehrzeilige Strings behalten Formatierung â€“ ideal fÃ¼r ASCII-Art oder Konsolenprogramme.</li>
        </ul>
    </section>

    <section>
        <h2>5. Zeichenzugriff & Substrings</h2>
        <ul>
            <li>Zeichenzugriff mit <code>string[index]</code>.</li>
            <li>Index beginnt bei 0: <code>name[2]</code> â†’ drittes Zeichen.</li>
            <li>Negative Indizes zÃ¤hlen von hinten: <code>-1</code> = letztes Zeichen.</li>
            <li><code>len(string)</code> gibt die LÃ¤nge zurÃ¼ck.</li>
            <li><code>string[len(string)-1]</code> â†’ letztes Zeichen.</li>
            <li>Fehlzugriff auÃŸerhalb des Bereichs fÃ¼hrt zu <code>IndexError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>6. Slicing</h2>
        <ul>
            <li>Slicing-Syntax: <code>string[start:end]</code> â€“ <code>end</code> ist exklusiv.</li>
            <li><code>string[0:3]</code> â†’ erste 3 Zeichen.</li>
            <li><code>string[:5]</code> â†’ von Anfang bis Index 4.</li>
            <li><code>string[3:]</code> â†’ ab Index 3 bis zum Ende.</li>
            <li><code>string[:]</code> â†’ gesamter String.</li>
            <li>Negative Indizes funktionieren auch: <code>string[-3:-1]</code> â†’ vorletzte 2 Zeichen.</li>
            <li>Start- und Endindex auÃŸerhalb der Grenzen sind erlaubt (keine Fehler).</li>
        </ul>
    </section>

    <section>
        <h2>7. Arithmetische Operatoren mit Strings</h2>
        <ul>
            <li><code>+</code> verkettet Strings (z.â€¯B. <code>"a" + "b"</code> â†’ "ab").</li>
            <li><code>*</code> dupliziert Strings (z.â€¯B. <code>"!" * 3</code> â†’ "!!!").</li>
            <li>Reihenfolge bei <code>*</code> egal: <code>3 * "a" == "a" * 3</code>.</li>
            <li>Nur Kombination <code>String * int</code> ist erlaubt â€“ nicht <code>String * String</code> oder
                <code>String - String</code>.</li>
            <li>Potenzieren mit <code>**</code> sowie Division <code>/</code> ist bei Strings nicht erlaubt.</li>
            <li>FehlerfÃ¤lle wie <code>"a" - "b"</code> oder <code>"a" ** 2</code> â†’ <code>TypeError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>8. String-Methoden</h2>
        <ul>
            <li><code>upper()</code>, <code>lower()</code>, <code>capitalize()</code> â€“ Buchstaben umwandeln.</li>
            <li><code>isupper()</code>, <code>islower()</code>, <code>isnumeric()</code>, <code>isalpha()</code> â€“
                RÃ¼ckgabe von <code>True</code> oder <code>False</code>.</li>
            <li><code>split(sep)</code>, <code>splitlines()</code> â€“ Zerlegen von Strings in Listen.</li>
            <li><code>strip()</code> â€“ entfernt Leerzeichen am Anfang/Ende.</li>
            <li><code>replace(old, new)</code> â€“ ersetzt Zeichen oder Substrings.</li>
            <li><code>count(sub)</code> â€“ zÃ¤hlt Vorkommen eines Zeichens/Substrings.</li>
            <li><code>index(sub)</code> â€“ Position des ersten Auftretens, Fehler bei Nichtfund.</li>
            <li><code>find(sub)</code> â€“ wie <code>index()</code>, aber ohne Fehler (liefert <code>-1</code>).</li>
            <li><code>"sub" in string</code> â€“ prÃ¼ft, ob Substring enthalten ist â†’ <code>True</code> oder
                <code>False</code>.</li>
        </ul>
    </section>

    <section>
        <h2>9. Anwendungsbeispiele & Aufgaben zu String-Methoden</h2>
        <ul>
            <li><code>upper()</code> wandelt alle Buchstaben in GroÃŸbuchstaben um.</li>
            <li><code>lower()</code> macht alle Buchstaben klein.</li>
            <li><code>capitalize()</code> schreibt nur den ersten Buchstaben groÃŸ, Rest klein.</li>
            <li><code>zfill(n)</code> fÃ¼llt einen String mit fÃ¼hrenden Nullen auf LÃ¤nge <code>n</code> auf.</li>
            <li><code>islower()</code> / <code>isupper()</code> prÃ¼fen, ob alle Buchstaben klein/groÃŸ sind.</li>
            <li><code>isalpha()</code> prÃ¼ft, ob nur Buchstaben enthalten sind.</li>
            <li><code>isnumeric()</code> prÃ¼ft, ob nur Ziffern enthalten sind.</li>
            <li><code>split(";")</code> trennt einen String anhand eines Trennzeichens (liefert Liste).</li>
            <li><code>replace("alt", "neu")</code> ersetzt Teilstrings gezielt.</li>
            <li><code>count("x")</code> zÃ¤hlt Vorkommen eines Zeichens oder Substrings.</li>
            <li><code>find("x")</code> liefert Index oder <code>-1</code>, wenn nicht gefunden.</li>
            <li><code>index("x")</code> wie <code>find</code>, aber mit Fehler bei Nichtfund.</li>
            <li><code>"x" in string</code> prÃ¼ft, ob <code>x</code> im String enthalten ist.</li>
            <li><code>string[::-1]</code> kehrt einen String um (Reversal per Slicing).</li>
        </ul>
    </section>

    <!-- Arithmetische Operatoren in Python -->
    <section id="arithmetische-operatoren">
        <h2>ğŸ§® Arithmetische Operatoren in Python</h2>
        <p>Hier siehst du eine Ãœbersicht typischer Rechenoperationen und deren Verhalten in Python:</p>

        <h3>1. Grundrechenarten</h3>
        <ul>
            <li><code>12 * 12</code> â†’ <strong>144</strong></li>
            <li><code>2.5 + 3.5</code> â†’ <strong>6.0</strong> (Float + Float = Float)</li>
            <li><code>20 / 5</code> â†’ <strong>4.0</strong> (Division liefert immer Float)</li>
            <li><code>15 - 3 * 5</code> â†’ <strong>0</strong> (Punktrechnung vor Strichrechnung)</li>
        </ul>

        <h3>2. Integer Division <code>//</code></h3>
        <ul>
            <li><code>8 + 10 // 4</code> â†’ <strong>10</strong></li>
            <li><code>8 + 10 / 4</code> â†’ <strong>10.5</strong></li>
            <li><code>20 / (5 - 4)</code> â†’ <strong>20.0</strong></li>
        </ul>

        <h3>3. Kombinationen & Reihenfolge</h3>
        <ul>
            <li><code>4 * 2.5 / 4</code> â†’ <strong>2.5</strong> (Links-nach-rechts-Auswertung)</li>
            <li><code>1 // 2 - 3 // 4</code> â†’ <strong>0</strong></li>
        </ul>

        <h3>4. Modulo <code>%</code></h3>
        <ul>
            <li><code>12 % 5</code> â†’ <strong>2</strong></li>
            <li><code>5 % 12</code> â†’ <strong>5</strong></li>
        </ul>

        <h3>5. Potenzen <code>**</code></h3>
        <ul>
            <li><code>2 ** 3</code> â†’ <strong>8</strong></li>
            <li><code>4 ** (8 - 5)</code> â†’ <strong>64</strong></li>
            <li><code>2 ** 8 // 2</code> â†’ <strong>128</strong></li>
            <li><code>5 ** 2 * 3</code> â†’ <strong>75</strong></li>
        </ul>

        <h3>6. String-Operationen</h3>
        <ul>
            <li><code>"Apfel" + "Baum"</code> â†’ <strong>"ApfelBaum"</strong></li>
            <li><code>5 * ("a" + "b")</code> â†’ <strong>"ababababab"</strong></li>
            <li><code>"x" * 2 ** 3</code> â†’ <strong>"xxxxxxxx"</strong></li>
        </ul>

        <h3>7. SonderfÃ¤lle</h3>
        <ul>
            <li><code>42 % 43</code> â†’ <strong>42</strong></li>
            <li><code>1024 % 2</code> â†’ <strong>0</strong></li>
            <li><code>5 * 4 * 3 * 2 * 1.0</code> â†’ <strong>120.0</strong></li>
            <li><code>0 * "Flo"</code> â†’ <strong>""</strong> (leerer String)</li>
            <li><code>"XYZ" * (12 % 5)</code> â†’ <strong>"XYZXYZ"</strong></li>
        </ul>
    </section>

    <section>
        <h2>11. Inkrementieren, Dekrementieren & Kurzschreibweisen</h2>
        <ul>
            <li>Python kennt keine <code>i++</code> oder <code>i--</code> Operatoren wie in C/Java.</li>
            <li>Stattdessen: kombinierte Zuweisungsoperatoren verwenden.</li>
            <li>Beispiele:
                <ul>
                    <li><code>i += 1</code> â†’ ErhÃ¶he <code>i</code> um 1</li>
                    <li><code>i -= 1</code> â†’ Verringere <code>i</code> um 1</li>
                    <li><code>i *= 2</code> â†’ Multipliziere <code>i</code> mit 2</li>
                    <li><code>i /= 2</code> â†’ Division mit float-Ergebnis</li>
                    <li><code>i //= 2</code> â†’ Ganzzahldivision (Integer)</li>
                    <li><code>i **= 2</code> â†’ Quadrat von <code>i</code></li>
                    <li><code>i %= 3</code> â†’ Rest bei Division durch 3</li>
                </ul>
            </li>
            <li>Die Kurzform spart Wiederholung der Variable und verbessert Lesbarkeit.</li>
        </ul>
    </section>
    <section>
        <h2>12. Vergleichsoperatoren</h2>
        <ul>
            <li>Vergleichsoperatoren geben immer <code>True</code> oder <code>False</code> zurÃ¼ck.</li>
            <li>VerfÃ¼gbare Operatoren:
                <ul>
                    <li><code>a < b</code> â†’ kleiner als</li>
                    <li><code>a <= b</code> â†’ kleiner oder gleich</li>
                    <li><code>a == b</code> â†’ gleich</li>
                    <li><code>a != b</code> â†’ ungleich</li>
                    <li><code>a > b</code> â†’ grÃ¶ÃŸer als</li>
                    <li><code>a >= b</code> â†’ grÃ¶ÃŸer oder gleich</li>
                </ul>
            </li>
            <li>Funktioniert mit Zahlen, Strings (alphabetisch) und spÃ¤ter auch mit Objekten.</li>
            <li>Beispiel:
                <code>"Flo" < "Florian"</code> â†’ <code>True</code> (wegen alphabetischer Ordnung)
            </li>
            <li>Alle Vergleichsoperatoren haben die gleiche BindungsstÃ¤rke und werden von links nach rechts ausgewertet.
            </li>
        </ul>
    </section>

    <section>
        <h2>13. Logische Operatoren</h2>
        <ul>
            <li>VerknÃ¼pfen Wahrheitswerte (<code>True</code> oder <code>False</code>).</li>
            <li>Ergebnisse sind stets <code>True</code> oder <code>False</code>.</li>
            <li>Operatoren:
                <ul>
                    <li><code>and</code> â†’ nur <code>True</code>, wenn beide Bedingungen <code>True</code> sind.</li>
                    <li><code>or</code> â†’ <code>True</code>, wenn mindestens eine Bedingung <code>True</code> ist.</li>
                    <li><code>not</code> â†’ kehrt den Wahrheitswert um.</li>
                    <li><code>^</code> (XOR) â†’ <code>True</code>, wenn genau eine Bedingung <code>True</code> ist.</li>
                </ul>
            </li>
            <li>Beispiele:
                <ul>
                    <li><code>2 &lt; 3 and 3 &lt; 5</code> â†’ <code>True</code></li>
                    <li><code>not (3 == 5)</code> â†’ <code>True</code></li>
                    <li><code>True ^ False</code> â†’ <code>True</code></li>
                </ul>
            </li>
            <li>Operatorrangfolge:
                <ul>
                    <li><strong>1.</strong> <code>not</code></li>
                    <li><strong>2.</strong> <code>and</code></li>
                    <li><strong>3.</strong> <code>or</code></li>
                </ul>
            </li>
            <li>Nutze <code>()</code>, um Auswertungsreihenfolge gezielt zu steuern.</li>
        </ul>
    </section>

    <section>
        <h2>14. Logik-Aufgaben & Kombinationen</h2>
        <ul>
            <li><strong>Operatoren:</strong> <code>and</code>, <code>or</code>, <code>not</code>, <code>^</code> (XOR).
            </li>
            <li><strong>Ergebnisse:</strong> Immer <code>True</code> oder <code>False</code>.</li>
            <li><strong>Operatorrangfolge:</strong>
                <ul>
                    <li><code>not</code> bindet am stÃ¤rksten</li>
                    <li><code>and</code> folgt</li>
                    <li><code>or</code> danach</li>
                    <li><code>^</code> (XOR) ist ein bitweiser Operator mit hoher Bindung</li>
                </ul>
            </li>
            <li><strong>Verwendung in Bedingungen:</strong> Vergleichs- und arithmetische Operatoren werden zuerst
                ausgewertet, danach logische Operatoren.</li>
            <li><strong>Beispiele:</strong>
                <ul>
                    <li><code>True and False or True</code> â†’ <code>True</code></li>
                    <li><code>not False</code> â†’ <code>True</code></li>
                    <li><code>True ^ True</code> â†’ <code>False</code></li>
                    <li><code>2 % 5 == 2</code> â†’ <code>True</code></li>
                    <li><code>not not not (2 % 5 == 2)</code> â†’ <code>False</code></li>
                </ul>
            </li>
            <li><strong>Unterschied:</strong>
                <ul>
                    <li><code>or</code>: beides darf <code>True</code> sein (z.â€¯B. â€Milch oder Zuckerâ€œ)</li>
                    <li><code>^</code>: nur eins darf <code>True</code> sein (â€entweder Big Mac oder Big Tastyâ€œ)</li>
                </ul>
            </li>
            <li><strong>Mix mit Zahlen:</strong> <code>True ^ 0</code> ergibt <code>1</code> (kein Boolean, sondern
                Integer!)</li>
        </ul>
    </section>

    <section>
        <h2>15. Operatorrangfolge</h2>
        <p>Die folgende Tabelle zeigt die Reihenfolge, in der Operatoren in Python ausgewertet werden (von oben nach
            unten â€“ hÃ¶chste zu niedrigster Bindung):</p>
        <table border="1" cellpadding="6" cellspacing="0">
            <thead>
                <tr>
                    <th>PrioritÃ¤t</th>
                    <th>Operator(en)</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td><code>**</code></td>
                    <td>Potenz (Exponentiation)</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
                    <td>Multiplikation, Division, ganzzahlige Division, Modulo</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><code>+</code>, <code>-</code></td>
                    <td>Addition, Subtraktion</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td><code>^</code></td>
                    <td>Bitweises XOR (zÃ¤hlt technisch zu bitweisen Operatoren)</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>,
                        <code>&gt;</code></td>
                    <td>Vergleichsoperatoren</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td><code>not</code></td>
                    <td>Logische Negation</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td><code>and</code></td>
                    <td>Logisches UND</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td><code>or</code></td>
                    <td>Logisches ODER (schwÃ¤chste Bindung)</td>
                </tr>
            </tbody>
        </table>
        <p>Tipp: Wenn du eine andere Reihenfolge erzwingen willst, nutze Klammern <code>()</code>.</p>
    </section>
    <section>
        <h2>11. If-Anweisung</h2>
        <ul>
            <li><code>if</code> prÃ¼ft eine Bedingung und fÃ¼hrt Code nur aus, wenn sie <code>True</code> ergibt.</li>
            <li>Syntax:
                <pre><code>if BEDINGUNG:
    # tue etwas
else:
    # tue etwas anderes</code></pre>
            </li>
            <li>Vergleich mit <code>==</code>, nicht mit <code>=</code> (Zuweisung!).</li>
            <li>EinrÃ¼ckung nach dem <code>:</code> ist zwingend (meist 4 Leerzeichen).</li>
            <li><code>else</code> ist optional, darf aber nur mit passendem <code>if</code> verwendet werden.</li>
            <li>Beispiel:
                <pre><code>passwort = input("Gib dein Passwort ein:")
if passwort == "ABC123":
    print("Das Passwort ist korrekt.")
else:
    print("Das Passwort ist nicht korrekt.")</code></pre>
            </li>
        </ul>
    </section>
    <section>
    <h2>12. Mehrfache Bedingungen mit <code>elif</code></h2>
    <ul>
        <li><code>elif</code> steht fÃ¼r â€else ifâ€œ â€“ wird geprÃ¼ft, wenn die <code>if</code>-Bedingung nicht zutrifft.</li>
        <li><code>else</code> fÃ¤ngt alle Ã¼brigen FÃ¤lle auf, wenn keine vorherige Bedingung zutrifft.</li>
        <li>Nur der erste passende Block wird ausgefÃ¼hrt â€“ danach wird der Rest ignoriert.</li>
        <li>Syntax:
            <pre><code>if BEDINGUNG:
    ANWEISUNG
elif ANDERE_BEDINGUNG:
    ANWEISUNG
else:
    ANWEISUNG</code></pre>
        </li>
        <li>Beispiel:
            <pre><code>note = input("Gib die Schulnote ein (1â€“6): ")

if note == "1":
    print("Sehr gut!")
elif note == "2":
    print("Gut")
elif note == "3":
    print("Befriedigend")
elif note == "4":
    print("Ausreichend")
elif note == "5":
    print("Mangelhaft")
elif note == "6":
    print("UngenÃ¼gend")
else:
    print("UngÃ¼ltige Eingabe")</code></pre>
        </li>
        <li>Tipp: FÃ¼r numerische Eingaben <code>int()</code> verwenden:
            <pre><code>note = int(input("Gib die Schulnote als Zahl ein: "))</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>10. Match-Case (ab Python 3.10)</h2>
    <ul>
        <li><code>match</code> prÃ¼ft den Wert einer Variable gegen mehrere <code>case</code>-FÃ¤lle.</li>
        <li>Ã„hnlich wie <code>switch-case</code> in anderen Sprachen, aber leistungsfÃ¤higer.</li>
        <li><code>case _</code> entspricht einem <code>else</code>-Zweig â€“ wird ausgefÃ¼hrt, wenn kein anderer <code>case</code> passt.</li>
        <li>Beispiel mit Strings:
            <pre><code>match note:
    case "1":
        print("Sehr gut!")
    case "2":
        print("Gut")
    case _:
        print("UngÃ¼ltige Eingabe.")</code></pre>
        </li>
        <li>Auch mit <code>int</code> mÃ¶glich â€“ z.â€¯B. <code>match int(note):</code></li>
        <li>Erweiterbar auf Listen, Tupel oder eigene Objekte (Pattern Matching).</li>
    </ul>
</section>

<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen CodeblÃ¶cke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird â€“ sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen CodeblÃ¶cke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird â€“ sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>12. For-Schleifen</h2>
    <ul>
        <li>Eine <code>for</code>-Schleife wird verwendet, um eine definierte Anzahl an DurchlÃ¤ufen Ã¼ber eine Datenstruktur (z.â€¯B. Liste, Tupel, <code>range()</code>) durchzufÃ¼hren.</li>
        <li><code>for element in iterable:</code> â†’ Jeder Eintrag wird nacheinander der Variablen zugewiesen.</li>
        <li>Beispiel:
            <pre><code>passwoerter = ["abc123", "geheim", "test", "123456"]
for passwort in passwoerter:
    print(passwort)</code></pre>
        </li>
        <li><code>break</code> bricht die Schleife vorzeitig ab, z.â€¯B. bei einer Abbruchbedingung:
            <pre><code>if len(passwort) &lt; 5:
    break</code></pre>
        </li>
        <li>Funktioniert mit Listen, Tupeln, Sets, Dictionaries, Strings & <code>range()</code>.</li>
        <li>Besonders leserlich durch Python's iterator-basierten Ansatz.</li>
    </ul>
</section>
<section>
    <h2>13. Endlosschleifen</h2>
    <p>Endlosschleifen entstehen, wenn eine <code>while</code>-Schleife nie endet, weil ihre Bedingung dauerhaft <code>True</code> bleibt.</p>
    <p>Beispiel einer fehlerhaften <code>while</code>-Schleife:</p>
    <pre><code>teilnehmer = input("Teilnehmer eingeben: ")
teilnehmer_liste = []

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    # Eingabe fehlt hier â†’ Endlosschleife</code></pre>
    <p><strong>Richtig:</strong> Eingabe innerhalb der Schleife erneut abfragen:</p>
    <pre><code>teilnehmer_liste = []
teilnehmer = input("Teilnehmer eingeben (X zum Beenden): ")

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    teilnehmer = input("NÃ¤chster Teilnehmer (X zum Beenden): ")</code></pre>
    <p>Alternativ mit <code>while True</code> und <code>break</code> absichern:</p>
    <pre><code>i = 0
while True:
    if i == 3:
        break
    print("Durchlauf", i)
    i += 1</code></pre>
    <p>ğŸ’¡ Achte darauf, dass sich die Bedingung in der Schleife irgendwann Ã¤ndert â€“ sonst lÃ¤uft sie unendlich weiter.</p>
</section>

<section>
  <h2>14. Unterschied: for vs. while</h2>
  <p>ğŸ” Python kennt zwei Haupt-Schleifentypen:</p>
  <ul>
    <li><strong><code>for</code>-Schleife:</strong> Wiederholt einen Codeblock <em>eine festgelegte Anzahl an Malen</em> â€“ typischerweise Ã¼ber Datenstrukturen wie Listen, Tupel oder Strings.</li>
    <li><strong><code>while</code>-Schleife:</strong> Wiederholt den Codeblock <em>solange eine Bedingung wahr ist</em> â€“ die Laufzeit ist also abhÃ¤ngig von Benutzeraktionen oder Programmlogik.</li>
  </ul>

  <h3>ğŸ§  Vergleich</h3>
  <table>
    <thead>
      <tr>
        <th>Eigenschaft</th>
        <th><code>for</code>-Schleife</th>
        <th><code>while</code>-Schleife</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>â³ Laufzeit</td>
        <td>Vordefiniert (z.&nbsp;B. durch LÃ¤nge einer Liste)</td>
        <td>AbhÃ¤ngig von einer Bedingung</td>
      </tr>
      <tr>
        <td>ğŸ“¦ Typischer Einsatz</td>
        <td>Datenstrukturen durchlaufen</td>
        <td>Benutzereingaben, Event Loops, Server-Ãœberwachung</td>
      </tr>
      <tr>
        <td>âŒ Endlosschleifen mÃ¶glich?</td>
        <td>Nein (endet automatisch nach X DurchlÃ¤ufen)</td>
        <td>Ja (z.&nbsp;B. durch <code>while True</code>)</td>
      </tr>
      <tr>
        <td>ğŸ”§ Benutzerabbruch</td>
        <td>Nur mit <code>break</code> bei zusÃ¤tzlicher PrÃ¼fung</td>
        <td>Einfach durch Eingabebedingung steuerbar</td>
      </tr>
    </tbody>
  </table>

  <p>ğŸ’¡ <strong>Fazit:</strong> Verwende <code>for</code>, wenn die Anzahl der DurchlÃ¤ufe bekannt ist (z.&nbsp;B. Liste, String, range), und <code>while</code>, wenn du flexibel auf Bedingungen oder Benutzereingaben reagieren musst.</p>
</section>
<section>
  <h2>15. Walross-Operator <code>:=</code></h2>
  <p>
    Seit Pythonâ€¯3.8 gibt es den sogenannten <strong>Walross-Operator</strong> <code>:=</code> (auch â€<em>assignment expression</em>â€œ genannt).
    Er erlaubt, einer Variablen innerhalb einer Bedingung <em>einen Wert zuzuweisen und diesen gleichzeitig zu prÃ¼fen</em> â€“ ideal fÃ¼r kompakte, lesbare Schleifen.
  </p>

  <h3>ğŸ“š Beispiel: Teilnehmerliste mit <code>while</code>-Schleife</h3>
  <pre><code>teilnehmerliste = []

while (teilnehmer := input("Gib einen Teilnehmer ein: ")) != "x":
    teilnehmerliste.append(teilnehmer)

print("Teilnehmerliste:", teilnehmerliste)</code></pre>

  <h3>ğŸ§  Vorteile:</h3>
  <ul>
    <li>Vermeidet doppelte Codezeilen wie <code>input(...)</code> vor und in der Schleife.</li>
    <li>ErhÃ¶ht die Lesbarkeit & reduziert Fehler durch Copy-Paste.</li>
    <li>Perfekt fÃ¼r kompakte while-Bedingungen mit Zuweisung.</li>
  </ul>

  <p>ğŸ’¡ Merkhilfe: Der Operator <code>:=</code> sieht aus wie das Gesicht eines ğŸ¦­â€¯Walrosses â€“ daher der Name.</p>
</section>
<section>
  <h2>16. Listen in Python</h2>
  <ul>
    <li>Listen sind <strong>flexibel</strong> und <strong>dynamisch</strong>: Sie kÃ¶nnen verschiedene Datentypen enthalten (z.â€¯B. <code>int</code>, <code>str</code>, <code>bool</code>).</li>
    <li>Erstellung: <code>liste = []</code> (leere Liste) oder z.â€¯B. <code>liste = [42, "Florian", True]</code></li>
    <li>LÃ¤nge ermitteln mit <code>len(liste)</code></li>
    <li>Zugriff Ã¼ber Index: <code>liste[0]</code>, <code>liste[-1]</code> (letztes Element)</li>
    <li><strong>Slicing</strong>: <code>liste[1:4]</code> â€“ liefert eine Teilliste (Start inkl., Ende exkl.)</li>
    <li>Out-of-Range beim <strong>Slicing</strong> ist erlaubt â†’ kein Fehler.</li>
    <li>Out-of-Range bei direktem Indexzugriff (<code>liste[99]</code>) fÃ¼hrt zu <code>IndexError</code>.</li>
  </ul>
</section>
<section>
  <h2>Kapitel 17 â€“ Listenmethoden</h2>
  <p>Listen sind dynamische Datenstrukturen in Python, die Elemente verschiedenster Typen aufnehmen kÃ¶nnen. Sie bieten eine Vielzahl an Methoden zur Bearbeitung.</p>

  <h3>Elemente hinzufÃ¼gen</h3>
  <ul>
    <li><code>+</code> zum Verketten von Listen</li>
    <li><code>*</code> zur Wiederholung von Listen</li>
    <li><code>.append(wert)</code> â€“ HÃ¤ngt ein einzelnes Element an</li>
    <li><code>.insert(index, wert)</code> â€“ FÃ¼gt ein Element an gegebener Position ein</li>
  </ul>

  <h3>Elemente entfernen</h3>
  <ul>
    <li><code>.remove(wert)</code> â€“ Entfernt das erste Vorkommen</li>
    <li><code>.clear()</code> â€“ Leert die gesamte Liste</li>
  </ul>

  <h3>Weitere Methoden</h3>
  <ul>
    <li><code>.count(wert)</code> â€“ ZÃ¤hlt, wie oft ein Wert vorkommt</li>
    <li><code>.sort()</code> â€“ Sortiert die Liste (optional: <code>reverse=True</code>)</li>
    <li><code>.copy()</code> â€“ Erstellt eine echte Kopie</li>
    <li><code>.index(wert)</code> â€“ Gibt die erste Indexposition eines Werts zurÃ¼ck</li>
    <li><code>w in liste</code> â€“ PrÃ¼ft, ob <code>w</code> enthalten ist</li>
  </ul>

  <h3>String-Methode <code>.join()</code></h3>
  <p>Wird auf einen String angewendet und verbindet die Elemente einer String-Liste:</p>
  <pre><code>'-'.join(["A", "B", "C"])  # "A-B-C"</code></pre>
</section>
<!-- Tupel in Python -->
<section id="tupel-python">
  <h2>ğŸ“˜ Tupel in Python</h2>
  <p>Tupel sind eine unverÃ¤nderliche Datenstruktur in Python, Ã¤hnlich wie Listen, aber starr.</p>

  <h3>ğŸ§© Eigenschaften</h3>
  <ul>
    <li>UnverÃ¤nderlich: keine Elemente hinzufÃ¼gen, lÃ¶schen oder Ã¤ndern</li>
    <li>Festgelegte LÃ¤nge und Reihenfolge</li>
    <li>Ideal fÃ¼r konstante Werte wie Koordinaten oder FunktionsrÃ¼ckgaben</li>
  </ul>

  <h3>ğŸ§ª Syntax</h3>
  <pre><code>mein_tupel = (1, 2, 3)
leeres_tupel = ()
</code></pre>

  <h3>ğŸ“ LÃ¤nge bestimmen</h3>
  <pre><code>len((1, 2, 3))  # â†’ 3</code></pre>

  <h3>ğŸ¯ Zugriff auf Elemente</h3>
  <pre><code>t = (4, 5, 29, 7)
t[2]    # â†’ 29
t[-2]   # â†’ 29 (von hinten)</code></pre>

  <h3>ğŸ” Direktzugriff ohne Variable</h3>
  <pre><code>print((4, 5, 29, 7)[-2])  # â†’ 29</code></pre>

  <h3>âš™ï¸ Tupel als RÃ¼ckgabe von Funktionen</h3>
  <pre><code>def addieren(a, b):
    return a, b, a + b

ergebnis = addieren(1, 4)
print(ergebnis)        # â†’ (1, 4, 5)
print(type(ergebnis))  # â†’ &lt;class 'tuple'&gt;</code></pre>

  <h3>ğŸ§  *args â†’ automatisch Tupel</h3>
  <pre><code>def addieren(*summanden):
    print(type(summanden))  # â†’ &lt;class 'tuple'&gt;
    return sum(summanden)

addieren(1, 2, 3)  # â†’ 6</code></pre>

  <h3>ğŸ“Œ Merksatz</h3>
  <blockquote>
    Tupel = Liste, die man nicht verÃ¤ndern darf.
  </blockquote>
</section>


</body>

</html>