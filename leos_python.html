<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Hinweise zu Python</title>
</head>

<body>
    <h1>Hinweise zu Python</h1>

    <section>
        <h2>1. Variablen</h2>
        <ul>
            <li>Variablen speichern Werte. Zuweisung erfolgt mit <code>=</code>.</li>
            <li>Beispiel: <code>name = "Anna"</code> oder <code>age = 25</code>.</li>
            <li>Mehrere Zuweisungen möglich: <code>name, age = "Lisa", 30</code>.</li>
            <li>Werte tauschen: <code>name, age = age, name</code>.</li>
            <li>Variablennamen dürfen nicht mit Zahlen beginnen, keine Sonderzeichen oder Keywords.</li>
            <li>Groß-/Kleinschreibung ist relevant: <code>name ≠ Name</code>.</li>
            <li>Vermeide „Magic Numbers“ – nutze stattdessen Variablen mit Bedeutung.</li>
        </ul>
    </section>

    <section>
        <h2>2. Datentypen</h2>
        <ul>
            <li>Python erkennt Datentypen automatisch (z. B. <code>str</code>, <code>int</code>, <code>float</code>,
                <code>bool</code>).</li>
            <li>Mit <code>type(var)</code> kannst du den Typ prüfen.</li>
            <li>Umwandlungen:
                <ul>
                    <li><code>str(25)</code> → "25"</li>
                    <li><code>int("27")</code> → 27</li>
                    <li><code>float("2.4")</code> → 2.4</li>
                    <li><code>bool("")</code> → False, <code>bool("abc")</code> → True</li>
                </ul>
            </li>
            <li>Fehler bei ungültiger Umwandlung: z. B. <code>int("27 Jahre")</code> → <code>ValueError</code>.</li>
            <li>0, 0.0, "" gelten als <code>False</code>, alle anderen Werte als <code>True</code>.</li>
        </ul>
    </section>

    <section>
        <h2>3. Umgebungsvariablen</h2>
        <ul>
            <li>Systemvariablen wie <code>PATH</code> oder <code>USER</code>.</li>
            <li>Zugriff in Python über <code>os.environ["NAME"]</code>.</li>
            <li><code>python-dotenv</code> ermöglicht das Einlesen einer <code>.env</code>-Datei.</li>
            <li><code>.env</code>-Datei enthält Key-Value-Paare, z. B. <code>USER_NAME=leo</code>.</li>
            <li><code>.env</code> gehört in die <code>.gitignore</code>.</li>
        </ul>
    </section>

    <section>
        <h2>4. Strings definieren</h2>
        <ul>
            <li>Strings mit <code>"Text"</code> oder <code>'Text'</code> definieren.</li>
            <li>Dreifache Anführungszeichen <code>""" """</code> für mehrzeilige Strings.</li>
            <li>Empfehlung:
                <ul>
                    <li>Ein Zeichen: <code>'A'</code></li>
                    <li>Mehrere Zeichen: <code>"Hallo"</code></li>
                    <li>Leerer String: <code>""</code></li>
                </ul>
            </li>
            <li>Mehrzeilige Strings behalten Formatierung – ideal für ASCII-Art oder Konsolenprogramme.</li>
        </ul>
    </section>

    <section>
        <h2>5. Zeichenzugriff & Substrings</h2>
        <ul>
            <li>Zeichenzugriff mit <code>string[index]</code>.</li>
            <li>Index beginnt bei 0: <code>name[2]</code> → drittes Zeichen.</li>
            <li>Negative Indizes zählen von hinten: <code>-1</code> = letztes Zeichen.</li>
            <li><code>len(string)</code> gibt die Länge zurück.</li>
            <li><code>string[len(string)-1]</code> → letztes Zeichen.</li>
            <li>Fehlzugriff außerhalb des Bereichs führt zu <code>IndexError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>6. Slicing</h2>
        <ul>
            <li>Slicing-Syntax: <code>string[start:end]</code> – <code>end</code> ist exklusiv.</li>
            <li><code>string[0:3]</code> → erste 3 Zeichen.</li>
            <li><code>string[:5]</code> → von Anfang bis Index 4.</li>
            <li><code>string[3:]</code> → ab Index 3 bis zum Ende.</li>
            <li><code>string[:]</code> → gesamter String.</li>
            <li>Negative Indizes funktionieren auch: <code>string[-3:-1]</code> → vorletzte 2 Zeichen.</li>
            <li>Start- und Endindex außerhalb der Grenzen sind erlaubt (keine Fehler).</li>
        </ul>
    </section>

    <section>
        <h2>7. Arithmetische Operatoren mit Strings</h2>
        <ul>
            <li><code>+</code> verkettet Strings (z. B. <code>"a" + "b"</code> → "ab").</li>
            <li><code>*</code> dupliziert Strings (z. B. <code>"!" * 3</code> → "!!!").</li>
            <li>Reihenfolge bei <code>*</code> egal: <code>3 * "a" == "a" * 3</code>.</li>
            <li>Nur Kombination <code>String * int</code> ist erlaubt – nicht <code>String * String</code> oder
                <code>String - String</code>.</li>
            <li>Potenzieren mit <code>**</code> sowie Division <code>/</code> ist bei Strings nicht erlaubt.</li>
            <li>Fehlerfälle wie <code>"a" - "b"</code> oder <code>"a" ** 2</code> → <code>TypeError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>8. String-Methoden</h2>
        <ul>
            <li><code>upper()</code>, <code>lower()</code>, <code>capitalize()</code> – Buchstaben umwandeln.</li>
            <li><code>isupper()</code>, <code>islower()</code>, <code>isnumeric()</code>, <code>isalpha()</code> –
                Rückgabe von <code>True</code> oder <code>False</code>.</li>
            <li><code>split(sep)</code>, <code>splitlines()</code> – Zerlegen von Strings in Listen.</li>
            <li><code>strip()</code> – entfernt Leerzeichen am Anfang/Ende.</li>
            <li><code>replace(old, new)</code> – ersetzt Zeichen oder Substrings.</li>
            <li><code>count(sub)</code> – zählt Vorkommen eines Zeichens/Substrings.</li>
            <li><code>index(sub)</code> – Position des ersten Auftretens, Fehler bei Nichtfund.</li>
            <li><code>find(sub)</code> – wie <code>index()</code>, aber ohne Fehler (liefert <code>-1</code>).</li>
            <li><code>"sub" in string</code> – prüft, ob Substring enthalten ist → <code>True</code> oder
                <code>False</code>.</li>
        </ul>
    </section>

    <section>
        <h2>9. Anwendungsbeispiele & Aufgaben zu String-Methoden</h2>
        <ul>
            <li><code>upper()</code> wandelt alle Buchstaben in Großbuchstaben um.</li>
            <li><code>lower()</code> macht alle Buchstaben klein.</li>
            <li><code>capitalize()</code> schreibt nur den ersten Buchstaben groß, Rest klein.</li>
            <li><code>zfill(n)</code> füllt einen String mit führenden Nullen auf Länge <code>n</code> auf.</li>
            <li><code>islower()</code> / <code>isupper()</code> prüfen, ob alle Buchstaben klein/groß sind.</li>
            <li><code>isalpha()</code> prüft, ob nur Buchstaben enthalten sind.</li>
            <li><code>isnumeric()</code> prüft, ob nur Ziffern enthalten sind.</li>
            <li><code>split(";")</code> trennt einen String anhand eines Trennzeichens (liefert Liste).</li>
            <li><code>replace("alt", "neu")</code> ersetzt Teilstrings gezielt.</li>
            <li><code>count("x")</code> zählt Vorkommen eines Zeichens oder Substrings.</li>
            <li><code>find("x")</code> liefert Index oder <code>-1</code>, wenn nicht gefunden.</li>
            <li><code>index("x")</code> wie <code>find</code>, aber mit Fehler bei Nichtfund.</li>
            <li><code>"x" in string</code> prüft, ob <code>x</code> im String enthalten ist.</li>
            <li><code>string[::-1]</code> kehrt einen String um (Reversal per Slicing).</li>
        </ul>
    </section>

    <!-- Arithmetische Operatoren in Python -->
    <section id="arithmetische-operatoren">
        <h2>🧮 Arithmetische Operatoren in Python</h2>
        <p>Hier siehst du eine Übersicht typischer Rechenoperationen und deren Verhalten in Python:</p>

        <h3>1. Grundrechenarten</h3>
        <ul>
            <li><code>12 * 12</code> → <strong>144</strong></li>
            <li><code>2.5 + 3.5</code> → <strong>6.0</strong> (Float + Float = Float)</li>
            <li><code>20 / 5</code> → <strong>4.0</strong> (Division liefert immer Float)</li>
            <li><code>15 - 3 * 5</code> → <strong>0</strong> (Punktrechnung vor Strichrechnung)</li>
        </ul>

        <h3>2. Integer Division <code>//</code></h3>
        <ul>
            <li><code>8 + 10 // 4</code> → <strong>10</strong></li>
            <li><code>8 + 10 / 4</code> → <strong>10.5</strong></li>
            <li><code>20 / (5 - 4)</code> → <strong>20.0</strong></li>
        </ul>

        <h3>3. Kombinationen & Reihenfolge</h3>
        <ul>
            <li><code>4 * 2.5 / 4</code> → <strong>2.5</strong> (Links-nach-rechts-Auswertung)</li>
            <li><code>1 // 2 - 3 // 4</code> → <strong>0</strong></li>
        </ul>

        <h3>4. Modulo <code>%</code></h3>
        <ul>
            <li><code>12 % 5</code> → <strong>2</strong></li>
            <li><code>5 % 12</code> → <strong>5</strong></li>
        </ul>

        <h3>5. Potenzen <code>**</code></h3>
        <ul>
            <li><code>2 ** 3</code> → <strong>8</strong></li>
            <li><code>4 ** (8 - 5)</code> → <strong>64</strong></li>
            <li><code>2 ** 8 // 2</code> → <strong>128</strong></li>
            <li><code>5 ** 2 * 3</code> → <strong>75</strong></li>
        </ul>

        <h3>6. String-Operationen</h3>
        <ul>
            <li><code>"Apfel" + "Baum"</code> → <strong>"ApfelBaum"</strong></li>
            <li><code>5 * ("a" + "b")</code> → <strong>"ababababab"</strong></li>
            <li><code>"x" * 2 ** 3</code> → <strong>"xxxxxxxx"</strong></li>
        </ul>

        <h3>7. Sonderfälle</h3>
        <ul>
            <li><code>42 % 43</code> → <strong>42</strong></li>
            <li><code>1024 % 2</code> → <strong>0</strong></li>
            <li><code>5 * 4 * 3 * 2 * 1.0</code> → <strong>120.0</strong></li>
            <li><code>0 * "Flo"</code> → <strong>""</strong> (leerer String)</li>
            <li><code>"XYZ" * (12 % 5)</code> → <strong>"XYZXYZ"</strong></li>
        </ul>
    </section>

    <section>
        <h2>11. Inkrementieren, Dekrementieren & Kurzschreibweisen</h2>
        <ul>
            <li>Python kennt keine <code>i++</code> oder <code>i--</code> Operatoren wie in C/Java.</li>
            <li>Stattdessen: kombinierte Zuweisungsoperatoren verwenden.</li>
            <li>Beispiele:
                <ul>
                    <li><code>i += 1</code> → Erhöhe <code>i</code> um 1</li>
                    <li><code>i -= 1</code> → Verringere <code>i</code> um 1</li>
                    <li><code>i *= 2</code> → Multipliziere <code>i</code> mit 2</li>
                    <li><code>i /= 2</code> → Division mit float-Ergebnis</li>
                    <li><code>i //= 2</code> → Ganzzahldivision (Integer)</li>
                    <li><code>i **= 2</code> → Quadrat von <code>i</code></li>
                    <li><code>i %= 3</code> → Rest bei Division durch 3</li>
                </ul>
            </li>
            <li>Die Kurzform spart Wiederholung der Variable und verbessert Lesbarkeit.</li>
        </ul>
    </section>
    <section>
        <h2>12. Vergleichsoperatoren</h2>
        <ul>
            <li>Vergleichsoperatoren geben immer <code>True</code> oder <code>False</code> zurück.</li>
            <li>Verfügbare Operatoren:
                <ul>
                    <li><code>a < b</code> → kleiner als</li>
                    <li><code>a <= b</code> → kleiner oder gleich</li>
                    <li><code>a == b</code> → gleich</li>
                    <li><code>a != b</code> → ungleich</li>
                    <li><code>a > b</code> → größer als</li>
                    <li><code>a >= b</code> → größer oder gleich</li>
                </ul>
            </li>
            <li>Funktioniert mit Zahlen, Strings (alphabetisch) und später auch mit Objekten.</li>
            <li>Beispiel:
                <code>"Flo" < "Florian"</code> → <code>True</code> (wegen alphabetischer Ordnung)
            </li>
            <li>Alle Vergleichsoperatoren haben die gleiche Bindungsstärke und werden von links nach rechts ausgewertet.
            </li>
        </ul>
    </section>

    <section>
        <h2>13. Logische Operatoren</h2>
        <ul>
            <li>Verknüpfen Wahrheitswerte (<code>True</code> oder <code>False</code>).</li>
            <li>Ergebnisse sind stets <code>True</code> oder <code>False</code>.</li>
            <li>Operatoren:
                <ul>
                    <li><code>and</code> → nur <code>True</code>, wenn beide Bedingungen <code>True</code> sind.</li>
                    <li><code>or</code> → <code>True</code>, wenn mindestens eine Bedingung <code>True</code> ist.</li>
                    <li><code>not</code> → kehrt den Wahrheitswert um.</li>
                    <li><code>^</code> (XOR) → <code>True</code>, wenn genau eine Bedingung <code>True</code> ist.</li>
                </ul>
            </li>
            <li>Beispiele:
                <ul>
                    <li><code>2 &lt; 3 and 3 &lt; 5</code> → <code>True</code></li>
                    <li><code>not (3 == 5)</code> → <code>True</code></li>
                    <li><code>True ^ False</code> → <code>True</code></li>
                </ul>
            </li>
            <li>Operatorrangfolge:
                <ul>
                    <li><strong>1.</strong> <code>not</code></li>
                    <li><strong>2.</strong> <code>and</code></li>
                    <li><strong>3.</strong> <code>or</code></li>
                </ul>
            </li>
            <li>Nutze <code>()</code>, um Auswertungsreihenfolge gezielt zu steuern.</li>
        </ul>
    </section>

    <section>
        <h2>14. Logik-Aufgaben & Kombinationen</h2>
        <ul>
            <li><strong>Operatoren:</strong> <code>and</code>, <code>or</code>, <code>not</code>, <code>^</code> (XOR).
            </li>
            <li><strong>Ergebnisse:</strong> Immer <code>True</code> oder <code>False</code>.</li>
            <li><strong>Operatorrangfolge:</strong>
                <ul>
                    <li><code>not</code> bindet am stärksten</li>
                    <li><code>and</code> folgt</li>
                    <li><code>or</code> danach</li>
                    <li><code>^</code> (XOR) ist ein bitweiser Operator mit hoher Bindung</li>
                </ul>
            </li>
            <li><strong>Verwendung in Bedingungen:</strong> Vergleichs- und arithmetische Operatoren werden zuerst
                ausgewertet, danach logische Operatoren.</li>
            <li><strong>Beispiele:</strong>
                <ul>
                    <li><code>True and False or True</code> → <code>True</code></li>
                    <li><code>not False</code> → <code>True</code></li>
                    <li><code>True ^ True</code> → <code>False</code></li>
                    <li><code>2 % 5 == 2</code> → <code>True</code></li>
                    <li><code>not not not (2 % 5 == 2)</code> → <code>False</code></li>
                </ul>
            </li>
            <li><strong>Unterschied:</strong>
                <ul>
                    <li><code>or</code>: beides darf <code>True</code> sein (z. B. „Milch oder Zucker“)</li>
                    <li><code>^</code>: nur eins darf <code>True</code> sein („entweder Big Mac oder Big Tasty“)</li>
                </ul>
            </li>
            <li><strong>Mix mit Zahlen:</strong> <code>True ^ 0</code> ergibt <code>1</code> (kein Boolean, sondern
                Integer!)</li>
        </ul>
    </section>

    <section>
        <h2>15. Operatorrangfolge</h2>
        <p>Die folgende Tabelle zeigt die Reihenfolge, in der Operatoren in Python ausgewertet werden (von oben nach
            unten – höchste zu niedrigster Bindung):</p>
        <table border="1" cellpadding="6" cellspacing="0">
            <thead>
                <tr>
                    <th>Priorität</th>
                    <th>Operator(en)</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td><code>**</code></td>
                    <td>Potenz (Exponentiation)</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
                    <td>Multiplikation, Division, ganzzahlige Division, Modulo</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><code>+</code>, <code>-</code></td>
                    <td>Addition, Subtraktion</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td><code>^</code></td>
                    <td>Bitweises XOR (zählt technisch zu bitweisen Operatoren)</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>,
                        <code>&gt;</code></td>
                    <td>Vergleichsoperatoren</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td><code>not</code></td>
                    <td>Logische Negation</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td><code>and</code></td>
                    <td>Logisches UND</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td><code>or</code></td>
                    <td>Logisches ODER (schwächste Bindung)</td>
                </tr>
            </tbody>
        </table>
        <p>Tipp: Wenn du eine andere Reihenfolge erzwingen willst, nutze Klammern <code>()</code>.</p>
    </section>
    <section>
        <h2>11. If-Anweisung</h2>
        <ul>
            <li><code>if</code> prüft eine Bedingung und führt Code nur aus, wenn sie <code>True</code> ergibt.</li>
            <li>Syntax:
                <pre><code>if BEDINGUNG:
    # tue etwas
else:
    # tue etwas anderes</code></pre>
            </li>
            <li>Vergleich mit <code>==</code>, nicht mit <code>=</code> (Zuweisung!).</li>
            <li>Einrückung nach dem <code>:</code> ist zwingend (meist 4 Leerzeichen).</li>
            <li><code>else</code> ist optional, darf aber nur mit passendem <code>if</code> verwendet werden.</li>
            <li>Beispiel:
                <pre><code>passwort = input("Gib dein Passwort ein:")
if passwort == "ABC123":
    print("Das Passwort ist korrekt.")
else:
    print("Das Passwort ist nicht korrekt.")</code></pre>
            </li>
        </ul>
    </section>
    <section>
    <h2>12. Mehrfache Bedingungen mit <code>elif</code></h2>
    <ul>
        <li><code>elif</code> steht für „else if“ – wird geprüft, wenn die <code>if</code>-Bedingung nicht zutrifft.</li>
        <li><code>else</code> fängt alle übrigen Fälle auf, wenn keine vorherige Bedingung zutrifft.</li>
        <li>Nur der erste passende Block wird ausgeführt – danach wird der Rest ignoriert.</li>
        <li>Syntax:
            <pre><code>if BEDINGUNG:
    ANWEISUNG
elif ANDERE_BEDINGUNG:
    ANWEISUNG
else:
    ANWEISUNG</code></pre>
        </li>
        <li>Beispiel:
            <pre><code>note = input("Gib die Schulnote ein (1–6): ")

if note == "1":
    print("Sehr gut!")
elif note == "2":
    print("Gut")
elif note == "3":
    print("Befriedigend")
elif note == "4":
    print("Ausreichend")
elif note == "5":
    print("Mangelhaft")
elif note == "6":
    print("Ungenügend")
else:
    print("Ungültige Eingabe")</code></pre>
        </li>
        <li>Tipp: Für numerische Eingaben <code>int()</code> verwenden:
            <pre><code>note = int(input("Gib die Schulnote als Zahl ein: "))</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>10. Match-Case (ab Python 3.10)</h2>
    <ul>
        <li><code>match</code> prüft den Wert einer Variable gegen mehrere <code>case</code>-Fälle.</li>
        <li>Ähnlich wie <code>switch-case</code> in anderen Sprachen, aber leistungsfähiger.</li>
        <li><code>case _</code> entspricht einem <code>else</code>-Zweig – wird ausgeführt, wenn kein anderer <code>case</code> passt.</li>
        <li>Beispiel mit Strings:
            <pre><code>match note:
    case "1":
        print("Sehr gut!")
    case "2":
        print("Gut")
    case _:
        print("Ungültige Eingabe.")</code></pre>
        </li>
        <li>Auch mit <code>int</code> möglich – z. B. <code>match int(note):</code></li>
        <li>Erweiterbar auf Listen, Tupel oder eigene Objekte (Pattern Matching).</li>
    </ul>
</section>

<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen Codeblöcke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird – sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen Codeblöcke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird – sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>12. For-Schleifen</h2>
    <ul>
        <li>Eine <code>for</code>-Schleife wird verwendet, um eine definierte Anzahl an Durchläufen über eine Datenstruktur (z. B. Liste, Tupel, <code>range()</code>) durchzuführen.</li>
        <li><code>for element in iterable:</code> → Jeder Eintrag wird nacheinander der Variablen zugewiesen.</li>
        <li>Beispiel:
            <pre><code>passwoerter = ["abc123", "geheim", "test", "123456"]
for passwort in passwoerter:
    print(passwort)</code></pre>
        </li>
        <li><code>break</code> bricht die Schleife vorzeitig ab, z. B. bei einer Abbruchbedingung:
            <pre><code>if len(passwort) &lt; 5:
    break</code></pre>
        </li>
        <li>Funktioniert mit Listen, Tupeln, Sets, Dictionaries, Strings & <code>range()</code>.</li>
        <li>Besonders leserlich durch Python's iterator-basierten Ansatz.</li>
    </ul>
</section>
<section>
    <h2>13. Endlosschleifen</h2>
    <p>Endlosschleifen entstehen, wenn eine <code>while</code>-Schleife nie endet, weil ihre Bedingung dauerhaft <code>True</code> bleibt.</p>
    <p>Beispiel einer fehlerhaften <code>while</code>-Schleife:</p>
    <pre><code>teilnehmer = input("Teilnehmer eingeben: ")
teilnehmer_liste = []

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    # Eingabe fehlt hier → Endlosschleife</code></pre>
    <p><strong>Richtig:</strong> Eingabe innerhalb der Schleife erneut abfragen:</p>
    <pre><code>teilnehmer_liste = []
teilnehmer = input("Teilnehmer eingeben (X zum Beenden): ")

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    teilnehmer = input("Nächster Teilnehmer (X zum Beenden): ")</code></pre>
    <p>Alternativ mit <code>while True</code> und <code>break</code> absichern:</p>
    <pre><code>i = 0
while True:
    if i == 3:
        break
    print("Durchlauf", i)
    i += 1</code></pre>
    <p>💡 Achte darauf, dass sich die Bedingung in der Schleife irgendwann ändert – sonst läuft sie unendlich weiter.</p>
</section>

<section>
  <h2>14. Unterschied: for vs. while</h2>
  <p>🔁 Python kennt zwei Haupt-Schleifentypen:</p>
  <ul>
    <li><strong><code>for</code>-Schleife:</strong> Wiederholt einen Codeblock <em>eine festgelegte Anzahl an Malen</em> – typischerweise über Datenstrukturen wie Listen, Tupel oder Strings.</li>
    <li><strong><code>while</code>-Schleife:</strong> Wiederholt den Codeblock <em>solange eine Bedingung wahr ist</em> – die Laufzeit ist also abhängig von Benutzeraktionen oder Programmlogik.</li>
  </ul>

  <h3>🧠 Vergleich</h3>
  <table>
    <thead>
      <tr>
        <th>Eigenschaft</th>
        <th><code>for</code>-Schleife</th>
        <th><code>while</code>-Schleife</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>⏳ Laufzeit</td>
        <td>Vordefiniert (z.&nbsp;B. durch Länge einer Liste)</td>
        <td>Abhängig von einer Bedingung</td>
      </tr>
      <tr>
        <td>📦 Typischer Einsatz</td>
        <td>Datenstrukturen durchlaufen</td>
        <td>Benutzereingaben, Event Loops, Server-Überwachung</td>
      </tr>
      <tr>
        <td>❌ Endlosschleifen möglich?</td>
        <td>Nein (endet automatisch nach X Durchläufen)</td>
        <td>Ja (z.&nbsp;B. durch <code>while True</code>)</td>
      </tr>
      <tr>
        <td>🔧 Benutzerabbruch</td>
        <td>Nur mit <code>break</code> bei zusätzlicher Prüfung</td>
        <td>Einfach durch Eingabebedingung steuerbar</td>
      </tr>
    </tbody>
  </table>

  <p>💡 <strong>Fazit:</strong> Verwende <code>for</code>, wenn die Anzahl der Durchläufe bekannt ist (z.&nbsp;B. Liste, String, range), und <code>while</code>, wenn du flexibel auf Bedingungen oder Benutzereingaben reagieren musst.</p>
</section>
<section>
  <h2>15. Walross-Operator <code>:=</code></h2>
  <p>
    Seit Python 3.8 gibt es den sogenannten <strong>Walross-Operator</strong> <code>:=</code> (auch „<em>assignment expression</em>“ genannt).
    Er erlaubt, einer Variablen innerhalb einer Bedingung <em>einen Wert zuzuweisen und diesen gleichzeitig zu prüfen</em> – ideal für kompakte, lesbare Schleifen.
  </p>

  <h3>📚 Beispiel: Teilnehmerliste mit <code>while</code>-Schleife</h3>
  <pre><code>teilnehmerliste = []

while (teilnehmer := input("Gib einen Teilnehmer ein: ")) != "x":
    teilnehmerliste.append(teilnehmer)

print("Teilnehmerliste:", teilnehmerliste)</code></pre>

  <h3>🧠 Vorteile:</h3>
  <ul>
    <li>Vermeidet doppelte Codezeilen wie <code>input(...)</code> vor und in der Schleife.</li>
    <li>Erhöht die Lesbarkeit & reduziert Fehler durch Copy-Paste.</li>
    <li>Perfekt für kompakte while-Bedingungen mit Zuweisung.</li>
  </ul>

  <p>💡 Merkhilfe: Der Operator <code>:=</code> sieht aus wie das Gesicht eines 🦭 Walrosses – daher der Name.</p>
</section>
<section>
  <h2>16. Listen in Python</h2>
  <ul>
    <li>Listen sind <strong>flexibel</strong> und <strong>dynamisch</strong>: Sie können verschiedene Datentypen enthalten (z. B. <code>int</code>, <code>str</code>, <code>bool</code>).</li>
    <li>Erstellung: <code>liste = []</code> (leere Liste) oder z. B. <code>liste = [42, "Florian", True]</code></li>
    <li>Länge ermitteln mit <code>len(liste)</code></li>
    <li>Zugriff über Index: <code>liste[0]</code>, <code>liste[-1]</code> (letztes Element)</li>
    <li><strong>Slicing</strong>: <code>liste[1:4]</code> – liefert eine Teilliste (Start inkl., Ende exkl.)</li>
    <li>Out-of-Range beim <strong>Slicing</strong> ist erlaubt → kein Fehler.</li>
    <li>Out-of-Range bei direktem Indexzugriff (<code>liste[99]</code>) führt zu <code>IndexError</code>.</li>
  </ul>
</section>
<section>
  <h2>Kapitel 17 – Listenmethoden</h2>
  <p>Listen sind dynamische Datenstrukturen in Python, die Elemente verschiedenster Typen aufnehmen können. Sie bieten eine Vielzahl an Methoden zur Bearbeitung.</p>

  <h3>Elemente hinzufügen</h3>
  <ul>
    <li><code>+</code> zum Verketten von Listen</li>
    <li><code>*</code> zur Wiederholung von Listen</li>
    <li><code>.append(wert)</code> – Hängt ein einzelnes Element an</li>
    <li><code>.insert(index, wert)</code> – Fügt ein Element an gegebener Position ein</li>
  </ul>

  <h3>Elemente entfernen</h3>
  <ul>
    <li><code>.remove(wert)</code> – Entfernt das erste Vorkommen</li>
    <li><code>.clear()</code> – Leert die gesamte Liste</li>
  </ul>

  <h3>Weitere Methoden</h3>
  <ul>
    <li><code>.count(wert)</code> – Zählt, wie oft ein Wert vorkommt</li>
    <li><code>.sort()</code> – Sortiert die Liste (optional: <code>reverse=True</code>)</li>
    <li><code>.copy()</code> – Erstellt eine echte Kopie</li>
    <li><code>.index(wert)</code> – Gibt die erste Indexposition eines Werts zurück</li>
    <li><code>w in liste</code> – Prüft, ob <code>w</code> enthalten ist</li>
  </ul>

  <h3>String-Methode <code>.join()</code></h3>
  <p>Wird auf einen String angewendet und verbindet die Elemente einer String-Liste:</p>
  <pre><code>'-'.join(["A", "B", "C"])  # "A-B-C"</code></pre>
</section>
<!-- Tupel in Python -->
<section id="tupel-python">
  <h2>📘 Tupel in Python</h2>
  <p>Tupel sind eine unveränderliche Datenstruktur in Python, ähnlich wie Listen, aber starr.</p>

  <h3>🧩 Eigenschaften</h3>
  <ul>
    <li>Unveränderlich: keine Elemente hinzufügen, löschen oder ändern</li>
    <li>Festgelegte Länge und Reihenfolge</li>
    <li>Ideal für konstante Werte wie Koordinaten oder Funktionsrückgaben</li>
  </ul>

  <h3>🧪 Syntax</h3>
  <pre><code>mein_tupel = (1, 2, 3)
leeres_tupel = ()
</code></pre>

  <h3>📏 Länge bestimmen</h3>
  <pre><code>len((1, 2, 3))  # → 3</code></pre>

  <h3>🎯 Zugriff auf Elemente</h3>
  <pre><code>t = (4, 5, 29, 7)
t[2]    # → 29
t[-2]   # → 29 (von hinten)</code></pre>

  <h3>🔁 Direktzugriff ohne Variable</h3>
  <pre><code>print((4, 5, 29, 7)[-2])  # → 29</code></pre>

  <h3>⚙️ Tupel als Rückgabe von Funktionen</h3>
  <pre><code>def addieren(a, b):
    return a, b, a + b

ergebnis = addieren(1, 4)
print(ergebnis)        # → (1, 4, 5)
print(type(ergebnis))  # → &lt;class 'tuple'&gt;</code></pre>

  <h3>🧠 *args → automatisch Tupel</h3>
  <pre><code>def addieren(*summanden):
    print(type(summanden))  # → &lt;class 'tuple'&gt;
    return sum(summanden)

addieren(1, 2, 3)  # → 6</code></pre>

  <h3>📌 Merksatz</h3>
  <blockquote>
    Tupel = Liste, die man nicht verändern darf.
  </blockquote>
</section>
<!-- Tupel: Methoden, Kopieren und Umwandeln -->
<section id="tupel-methoden">
  <h2>📘 Tupel: Methoden, Kopieren & Umwandeln</h2>
  <p>Tupel sind unveränderliche Datenstrukturen in Python – das bedeutet, dass viele Methoden, die Listen verändern, hier nicht funktionieren.</p>

  <h3>🔒 Keine Änderungsmethoden</h3>
  <ul>
    <li>Keine <code>append()</code>, <code>remove()</code> etc.</li>
    <li>Keine direkte Veränderung des Tupels möglich</li>
  </ul>

  <h3>➕ Tupel kombinieren</h3>
  <pre><code>t1 = (1, 2, 3)
t2 = (4, 5)
neu = t1 + t2  # → (1, 2, 3, 4, 5)</code></pre>

  <h3>🔍 Lesende Methoden</h3>
  <ul>
    <li><code>count()</code> – zählt, wie oft ein Element vorkommt</li>
    <li><code>index()</code> – gibt die Position des ersten Vorkommens zurück</li>
  </ul>
  <pre><code>t = (7, 1, 7, 2)
t.count(7)     # → 2
t.index(1)     # → 1</code></pre>

  <h3>🧪 Kopieren</h3>
  <ul>
    <li>Zuweisung <code>kopie = original</code> erzeugt einen Verweis</li>
    <li>Kein Problem, da Tupel unveränderbar sind</li>
  </ul>

  <h3>🔄 Sortieren durch Umwandlung</h3>
  <pre><code>t = (5, 2, 8, 1)
liste = list(t)
liste.sort()
print(liste)  # → [1, 2, 5, 8]</code></pre>

  <h3>📌 Merksätze</h3>
  <blockquote>
    Tupel erlauben nur lesende Methoden. <br>
    Für Sortierung: zuerst in Liste umwandeln!
  </blockquote>
</section>
<!-- Set-Methoden in Python -->
<section id="set-methoden">
  <h2>📘 Set-Methoden in Python</h2>
  <p>Sets sind Mengen ohne Duplikate und ohne feste Reihenfolge. Daher gibt es einige Methoden nicht, aber andere, die gut zu dieser Datenstruktur passen.</p>

  <h3>❌ Nicht vorhandene Methoden</h3>
  <ul>
    <li><code>count()</code> – nicht verfügbar, da keine Duplikate erlaubt sind</li>
    <li><code>index()</code> – nicht verfügbar, da Sets keine Reihenfolge haben</li>
  </ul>

  <h3>✅ Existierende Methoden & Operationen</h3>

  <h4>🔍 Vorhandensein prüfen</h4>
  <pre><code>5 in s  # → True
99 in s # → False</code></pre>

  <h4>➕ Hinzufügen: <code>add()</code></h4>
  <pre><code>s = {1, 2}
s.add(3)  # → {1, 2, 3}</code></pre>

  <h4>➖ Entfernen: <code>remove()</code></h4>
  <pre><code>s = {3, 5, 8}
s.remove(8)  # → {3, 5}</code></pre>

  <h4>🧹 Alles löschen: <code>clear()</code></h4>
  <pre><code>s.clear()  # → set()</code></pre>

  <h4>📋 Kopieren: <code>copy()</code></h4>
  <pre><code>kopie = original.copy()</code></pre>

  <h3>🔄 Sortieren (indirekt)</h3>
  <pre><code>s = {11, 2, 7}
liste = list(s)
liste.sort()
print(liste)  # → [2, 7, 11]</code></pre>

  <h3>📌 Merksatz</h3>
  <blockquote>
    Sets sind ungeordnet und einzigartig. <br>
    Für Sortierung → zuerst in eine Liste umwandeln.
  </blockquote>
</section>
<!-- Dictionaries in Python -->
<section id="dictionaries">
  <h2>📘 Dictionaries in Python – Einführung & Zugriff</h2>
  <p>Ein Dictionary ist eine Sammlung von Schlüssel-Wert-Paaren – vergleichbar mit einem Telefonbuch oder einem echten Wörterbuch.</p>

  <h3>🧩 Aufbau & Syntax</h3>
  <pre><code>{
  "Yunus": "01234",
  "Florian": "09876"
}</code></pre>
  <ul>
    <li><code>{}</code> → leeres Dictionary</li>
    <li>Schlüssel und Werte werden mit <code>:</code> verbunden</li>
    <li>Mehrere Paare werden mit <code>,</code> getrennt</li>
  </ul>

  <h3>🔍 Zugriff auf Werte</h3>
  <pre><code>telefonbuch.get("Yunus")      # → "01234"
telefonbuch["Yunus"]          # → "01234"
telefonbuch.get("Unbekannt")  # → None
telefonbuch["Unbekannt"]      # → KeyError!</code></pre>
  <p><strong>Tipp:</strong> Immer <code>get()</code> verwenden, wenn du nicht sicher bist, ob der Schlüssel existiert.</p>

  <h3>🔄 Werte & Typen</h3>
  <ul>
    <li>Werte können <code>str</code>, <code>int</code>, <code>list</code> oder andere Objekte sein</li>
    <li>Beispiel: <code>{"Yunus": [0,1,2,3]}</code></li>
  </ul>

  <h3>🔐 Erlaubte Schlüsseltypen</h3>
  <ul>
    <li><strong>Erlaubt:</strong> <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code></li>
    <li><strong>Verboten:</strong> <code>list</code>, <code>set</code>, <code>dict</code> (nicht hashbar)</li>
  </ul>

  <h3>📏 Länge ermitteln</h3>
  <pre><code>len(telefonbuch)  # → Anzahl der Einträge</code></pre>

  <h3>📌 Merksatz</h3>
  <blockquote>
    Dictionaries sind Schlüssel-Wert-Speicher. <br>
    Immer <code>get()</code> nutzen, wenn du Fehler vermeiden willst.
  </blockquote>
</section>
<!-- Dictionaries: Zugriff, Update, Löschen & Methoden -->
<section id="dictionaries-methoden">
  <h2>📘 Dictionaries – Zugriff, Update, Löschen & Methoden</h2>
  <p>Ein Dictionary speichert Schlüssel-Wert-Paare und bietet zahlreiche Methoden für sicheren Zugriff und Bearbeitung.</p>

  <h3>🔍 Zugriff auf Werte</h3>
  <ul>
    <li><code>dict["key"]</code> → direkter Zugriff (Achtung: <code>KeyError</code> möglich)</li>
    <li><code>dict.get("key")</code> → sicherer Zugriff, gibt <code>None</code> oder optionalen Default zurück</li>
  </ul>
  <pre><code>pw.get("abc123")               # → Wert
pw.get("ultrageheim")         # → None
pw.get("ultrageheim", "...")  # → "...", falls nicht vorhanden</code></pre>

  <h3>🛠 Werte aktualisieren</h3>
  <ul>
    <li><code>dict["key"] = neuer_wert</code> – aktualisiert oder fügt neu hinzu</li>
    <li><code>dict.update({"key": neuer_wert})</code> – empfohlene Methode</li>
  </ul>

  <h3>➖ Einträge löschen</h3>
  <ul>
    <li><code>del dict["key"]</code> – entfernt Schlüssel + Wert</li>
    <li><code>dict.clear()</code> – entfernt alle Einträge</li>
  </ul>

  <h3>📋 Dictionary kopieren</h3>
  <pre><code>kopie = original.copy()</code></pre>
  <p>⚠️ Nicht nur <code>=</code> verwenden, da das nur eine Referenz erzeugt!</p>

  <h3>🔑 Schlüssel & 🔓 Werte abrufen</h3>
  <pre><code>keys = dict.keys()
print(list(keys))  # echte Liste aller Schlüssel

values = dict.values()
print(list(values))  # echte Liste aller Werte</code></pre>

  <p>Beachte: <code>.keys()</code> & <code>.values()</code> liefern spezielle Objekte wie <code>dict_keys</code>, die per <code>list()</code> umgewandelt werden können.</p>

  <h3>📌 Merksätze</h3>
  <blockquote>
    Immer <code>.get()</code> statt <code>[]</code> bei unsicherem Zugriff verwenden.<br>
    <code>.update()</code> zum sicheren Ändern.<br>
    <code>.keys()</code> und <code>.values()</code> ggf. mit <code>list()</code> umwandeln.
  </blockquote>
</section>
<!-- Funktionen in Python -->
<section id="funktionen">
  <h2>🧠 Funktionen in Python – Definition, Aufruf & Rückgabe</h2>
  <p>Funktionen helfen dir, Code zu strukturieren, wiederverwendbar zu machen und Berechnungen elegant durchzuführen.</p>

  <h3>🔧 Funktionsdefinition</h3>
  <pre><code>def funktionsname(parameter1, parameter2):
    # Anweisungen (z. B. Berechnungen, Ausgaben)</code></pre>
  <ul>
    <li><code>def</code> – Einleitung der Funktion</li>
    <li>Einrückung statt geschweifter Klammern</li>
    <li>Parameter in Klammern (optional)</li>
  </ul>

  <h3>▶️ Aufruf einer Funktion</h3>
  <pre><code>def sag_hallo(name):
    print(f"Hallo {name}")

sag_hallo("Florian")</code></pre>

  <h3>📥 Mehrere Parameter</h3>
  <pre><code>def sag_hallo(vorname, nachname):
    print(f"Hallo {vorname} {nachname}")</code></pre>

  <h3>🔄 Rückgabewerte mit <code>return</code></h3>
  <pre><code>def addieren(a, b):
    summe = a + b
    return summe

ergebnis = addieren(10, 32)
print(f"Summe: {ergebnis}")</code></pre>

  <h3>📌 Wichtige Hinweise</h3>
  <ul>
    <li>Rückgabewerte nur per <code>return</code></li>
    <li>Variablen in Funktionen sind <strong>lokal</strong></li>
    <li>Leere Funktionen mit <code>pass</code> definieren</li>
    <li>Einrückung ist <strong>Pflicht</strong> – sie ersetzt <code>{}</code>!</li>
  </ul>

  <blockquote>
    Wiederverwendbarer Code = sauberer Code 💡<br>
    Nutze Funktionen für Berechnungen, Ausgaben & Organisation.
  </blockquote>
</section>

<!-- *args und variable Parameter in Python -->
<section id="args-funktionen">
  <h2>📦 *args – Beliebig viele Parameter an Funktionen übergeben</h2>
  <p>
    Wenn du nicht im Voraus weißt, wie viele Werte an eine Funktion übergeben werden sollen, kannst du mit <code>*args</code> flexibel bleiben.
  </p>

  <h3>🎯 Standard-Funktionsdefinition</h3>
  <pre><code>def addieren(a, b):
    return a + b</code></pre>
  <p>
    Problem: Du musst die Anzahl der Parameter <strong>fix vorgeben</strong>.
  </p>

  <h3>🚀 Lösung mit <code>*args</code></h3>
  <pre><code>def addieren(*summanden):
    return sum(summanden)</code></pre>

  <p>
    Diese Funktion akzeptiert eine <strong>beliebige Anzahl</strong> an Argumenten – sogar keine. Intern wird <code>summanden</code> als <strong>Tuple</strong> gespeichert.
  </p>

  <h3>🔢 Beispiel-Aufrufe</h3>
  <pre><code>addieren(1, 2, 3)           # → 6
addieren(10, 20, 30, 40)    # → 100
addieren()                  # → 0</code></pre>

  <h3>📌 Kombination mit fixen Parametern</h3>
  <pre><code>def lotto_spielen(vorname, nachname, *zahlen):
    print(f"Hallo {vorname} {nachname}")
    print("Deine Zahlen lauten:", zahlen)</code></pre>

  <p>Beim Aufruf müssen die fixen Parameter <strong>zuerst</strong> kommen:</p>
  <pre><code>lotto_spielen("Florian", "Deiwick", 4, 8, 15, 16, 23, 42)</code></pre>

  <h3>❌ Fehlerhafte Reihenfolge</h3>
  <pre><code># FALSCH:
lotto_spielen(4, 8, 15, 16, 23, 42, "Florian", "Deiwick")</code></pre>
  <p>
    → Führt zu einem Fehler, da Python nicht weiß, welche Werte zu den fixen und welche zu den variablen Parametern gehören.
  </p>

  <h3>🧠 Merksatz</h3>
  <blockquote>
    <strong>Immer zuerst die fixen Parameter</strong> (Positional Arguments),<br>
    danach die variablen Parameter mit <code>*args</code>.
  </blockquote>
</section>
<section id="kwargs">
  <h2>🧩 **kwargs – Variable Keyword-Argumente</h2>
  <p>Mit <code>**kwargs</code> kannst du <strong>beliebig viele benannte Argumente</strong> (Schlüssel-Wert-Paare) übergeben. Intern wird <code>kwargs</code> als <em>Dictionary</em> gespeichert.</p>

  <h3>🔧 Definition</h3>
  <pre><code>def info(**daten):
    print(daten)</code></pre>

  <h3>📥 Anwendung</h3>
  <pre><code>info(name="Max", alter=25)
# Ausgabe: {'name': 'Max', 'alter': 25}</code></pre>

  <h3>🧠 Zugriff mit <code>.get()</code></h3>
  <pre><code>def info(**daten):
    name = daten.get("name", "Unbekannt")
    alter = daten.get("alter", 0)
    print(f"{name} ist {alter} Jahre alt.")

info(name="Lena")
# Ausgabe: Lena ist 0 Jahre alt.</code></pre>

  <h3>📌 Eigenschaften</h3>
  <ul>
    <li><code>**kwargs</code> erlaubt <strong>benannte Parameter</strong> in beliebiger Anzahl.</li>
    <li>Reihenfolge ist <strong>egal</strong>.</li>
    <li><code>.get()</code> schützt vor Fehlern bei fehlenden Schlüsseln.</li>
  </ul>

  <h3>📎 Standardwerte (Fallback)</h3>
  <pre><code>daten.get("geschlecht", "nicht angegeben")</code></pre>

  <p>Ideal für <strong>flexible Funktionen</strong>, z. B. Webformulare oder APIs.</p>
</section>
<section id="funktionsreihenfolge">
  <h2>🔄 Aufrufreihenfolge von Parametern in Python-Funktionen</h2>

  <p>In Python muss beim Definieren von Funktionen eine bestimmte <strong>Reihenfolge der Parameter</strong> eingehalten werden, damit der Funktionsaufruf korrekt funktioniert. Diese Reihenfolge ist besonders wichtig bei Kombinationen aus <code>positional arguments</code>, <code>*args</code> und <code>**kwargs</code>.</p>

  <h3>✅ Erlaubte Reihenfolge bei der Funktionsdefinition:</h3>
  <ol>
    <li><strong>Positional arguments</strong> (z. B. <code>name</code>, <code>alter</code>)</li>
    <li><strong><code>*args</code></strong> – für eine <em>beliebige Anzahl an Positionsargumenten</em></li>
    <li><strong><code>**kwargs</code></strong> – für <em>beliebig viele benannte Argumente</em> (Schlüssel-Wert-Paare)</li>
  </ol>

  <h3>📌 Beispiel</h3>
  <pre><code>def daten_erfassen(id, vorname, nachname, *geodaten, **daten):
    print(f"ID: {id}")
    print(f"Vorname: {vorname}")
    print(f"Nachname: {nachname}")
    print(f"Geodaten: {geodaten}")
    print(f"Weitere Daten: {daten}")</code></pre>

  <h3>📥 Aufruf</h3>
  <pre><code>daten_erfassen(
  42,
  "Florian",
  "Daiwig",
  50.123, 8.678,           # Geodaten (args)
  email="florian@beispiel.de",
  beruf="Entwickler"       # keyword-args
)</code></pre>

  <h3>🛑 Nicht erlaubt!</h3>
  <p>Folgende Reihenfolge <strong>führt zu einem Fehler</strong>:</p>
  <pre><code>def falsch(*args, vorname, **kwargs):  # ❌ SyntaxError
    pass</code></pre>

  <h3>🧠 Merksatz:</h3>
  <blockquote>
    Erst <strong>normale Parameter</strong>, dann <code>*args</code>, am Ende <code>**kwargs</code>.
  </blockquote>
</section>
<section id="scoping">
  <h2>🔍 Scoping in Python</h2>
  <p>Scoping beschreibt, in welchem Bereich des Codes Variablen sichtbar und nutzbar sind. In Python unterscheidet man zwischen drei Haupt-Gültigkeitsbereichen:</p>

  <h3>1. Built-in Scope</h3>
  <ul>
    <li>Enthält alle eingebauten Funktionen und Keywords (z.&nbsp;B. <code>print</code>, <code>len</code>).</li>
    <li>Immer verfügbar, ohne Import.</li>
  </ul>

  <h3>2. Global Scope</h3>
  <ul>
    <li>Variablen, die außerhalb von Funktionen definiert sind.</li>
    <li>Sichtbar im gesamten Code derselben Datei.</li>
    <li>Veränderbar in Funktionen nur mit dem <code>global</code>-Keyword.</li>
  </ul>

  <h3>3. Local Scope</h3>
  <ul>
    <li>Variablen, die innerhalb von Funktionen deklariert werden.</li>
    <li>Nur innerhalb dieser Funktion sichtbar.</li>
    <li>Globale Variablen können <strong>nicht</strong> direkt überschrieben werden.</li>
  </ul>

  <h3>✅ Beispiel mit <code>global</code>:</h3>
  <pre><code>level = 0

def level_up():
    global level
    level += 1
  </code></pre>

  <p><strong>Merksatz:</strong> Zuerst wird im <em>lokalen Scope</em> gesucht, dann im <em>globalen</em>, zuletzt im <em>built-in Scope</em>.</p>
</section>
<section id="modul-import">
  <h2>📦 Modul entwickeln & einbinden</h2>
  <p>In Python lassen sich eigene Module leicht erstellen und wiederverwenden. Dazu erstellt man eine Datei, z.&nbsp;B. <code>taschenrechner.py</code>, mit Funktionen wie <code>addieren()</code>, <code>subtrahieren()</code> usw.</p>
  <p>Diese können dann in einem anderen Script wie <code>main.py</code> über <code>import taschenrechner</code> eingebunden werden. Zugriff auf die Funktionen erfolgt via <code>taschenrechner.addieren(1, 2)</code>.</p>
  <p>Alternativ kann man per <code>from taschenrechner import *</code> alle Funktionen direkt zugänglich machen. Achtung bei Namenskonflikten!</p>
  <p>Zur besseren Lesbarkeit empfiehlt sich die Verwendung von Aliasen wie <code>import taschenrechner as tr</code>.</p>
</section>
<section id="if-main">
  <h2>🧠 if <code>__name__ == "__main__"</code> in Python</h2>
  <p>
    Diese Kontrollstruktur sorgt dafür, dass bestimmte Codeblöcke nur ausgeführt werden, wenn das Skript <strong>direkt gestartet</strong> wird – nicht beim Import als Modul.
  </p>
  <pre><code>if __name__ == "__main__":
    # Dieser Code wird nur beim Direktstart ausgeführt
    main()</code></pre>
  <h3>Vorteile:</h3>
  <ul>
    <li>Verhindert unerwünschte Ausführung beim Modulimport</li>
    <li>Ermöglicht Testläufe innerhalb von Modulen</li>
    <li>Fördert saubere, modulare Programmstruktur</li>
  </ul>
  <h3>Beispiel:</h3>
  <pre><code># taschenrechner.py
def addiere(a, b):
    return a + b

if __name__ == "__main__":
    print(addiere(1, 2))</code></pre>
</section>
<section id="input-function">
  <h2>📥 input()-Funktion in Python</h2>
  <p>Mit <code>input()</code> lassen sich Benutzereingaben zur Laufzeit abfragen. Die Funktion gibt immer einen <strong>String</strong> zurück.</p>
  
  <h3>🔹 Syntax</h3>
  <pre><code>eingabe = input("Bitte gib deinen Namen ein: ")</code></pre>

  <h3>🔹 Typumwandlung für Berechnungen</h3>
  <pre><code>geburtsjahr = int(input("In welchem Jahr wurdest du geboren?\n"))
alter = 2023 - geburtsjahr</code></pre>
  <p>Da <code>input()</code> immer einen String liefert, muss eine Umwandlung z. B. mit <code>int()</code> erfolgen.</p>

  <h3>🔹 Fehleranfälligkeit</h3>
  <p>Gibt der Benutzer z. B. einen Text statt einer Zahl ein, entsteht ein <code>ValueError</code>. Beispiel:</p>
  <pre><code>ValueError: invalid literal for int() with base 10: 'Florian'</code></pre>

  <h3>🔹 Input als Blockierer</h3>
  <pre><code>input("Drücke Enter, um das Programm zu beenden.")</code></pre>
  <p>Die Ausführung pausiert, bis eine Eingabe erfolgt – nützlich bei Konsolenfenstern.</p>

  <h3>🔹 Gestaltungs-Tipps</h3>
  <ul>
    <li>Nutze <code>\n</code> für Zeilenumbrüche.</li>
    <li>Füge ein Leerzeichen ans Ende der Eingabeaufforderung hinzu, damit der Cursor richtig steht.</li>
  </ul>

  <h3>🔹 Beispiel: Altersberechnung</h3>
  <pre><code>jahr = int(input("In welchem Jahr wurdest du geboren?\n"))
alter = 2023 - jahr
print(f"Du bist {alter} Jahre alt.")</code></pre>
</section>
<section id="exec">
  <h2>⚠️ Die <code>exec()</code>-Funktion in Python</h2>

  <h3>🔍 Was ist <code>exec()</code>?</h3>
  <p>
    Die Funktion <code>exec()</code> führt Python-Code aus, der als <strong>String</strong> übergeben wird. Sie ist Teil der Standardbibliothek und erfordert keinen Import.
  </p>
  <pre><code>exec("print('Hallo Welt')")</code></pre>

  <h3>⚠️ Sicherheitsrisiken</h3>
  <ul>
    <li><strong>Ungeprüfte Benutzereingaben</strong> können beliebigen Code ausführen.</li>
    <li><strong>Verschleierter Code</strong> (z. B. Base64) kann Schadcode enthalten.</li>
    <li><strong>Keine Einschränkungen:</strong> Alles im String wird vollständig ausgeführt.</li>
  </ul>

  <h3>🔧 Beispiel mit Base64-codiertem Code</h3>
  <pre><code>import base64

code_encoded = "cHJpbnQoIkhlbGxvIFdvcmxkIik="
decoded = base64.b64decode(code_encoded).decode("utf-8")
exec(decoded)  # Führt: print("Hello World") aus</code></pre>

  <h3>🛡️ Empfehlungen</h3>
  <ul>
    <li><strong>Vermeide <code>exec()</code></strong>, wenn es nicht zwingend nötig ist.</li>
    <li><strong>Nutze Alternativen</strong> wie Funktionen oder sichere <code>eval()</code>-Ausdrücke.</li>
    <li><strong>Filtere Benutzereingaben</strong> (z. B. über Whitelisting).</li>
    <li><strong>Analysiere codierten Code</strong> (z. B. Base64) vor der Ausführung.</li>
  </ul>
</section>
<section>
    <h2>17. Objektorientierte Programmierung (OOP) in Python</h2>
    <ul>
        <li><strong>Klasse</strong> als Vorlage zur Strukturierung von Code – mit Eigenschaften und Methoden.</li>
        <li><code>__init__()</code>: Konstruktor zur Initialisierung von Objekt-Eigenschaften (z. B. <code>self.name</code>).</li>
        <li><strong>Objekt</strong>: Konkrete Instanz einer Klasse – z. B. <code>dog1 = Hund("braun", "Schäferhund", "Fritzi")</code>.</li>
        <li><code>self</code>: Verweis auf das aktuelle Objekt innerhalb der Klasse.</li>
        <li><strong>Methoden</strong>: Funktionen innerhalb einer Klasse, z. B. <code>def bellen(self):</code>.</li>
        <li><strong>Vererbung</strong>: Gemeinsame Funktionen und Eigenschaften in einer Oberklasse bündeln.</li>
        <li>Beispiel:
            <pre><code>class Hund(Saeugetier):
    def bellen(self):
        print("Wuff!")</code></pre>
        </li>
        <li>OOP fördert sauberen, wartbaren und wiederverwendbaren Code.</li>
    </ul>
</section>
<section>
    <h2>17. Objektorientierte Programmierung mit Python – Pokémon</h2>
    <h3>Teil 1: Klassen, Attribute und Methoden</h3>
    <ul>
        <li>Mit dem Schlüsselwort <code>class</code> wird eine Klasse definiert (z. B. <code>class Pokemon:</code>).</li>
        <li>Die Methode <code>__init__(self, name, level)</code> ist der sogenannte Konstruktor – sie wird beim Erzeugen (Instanziieren) eines Objekts automatisch aufgerufen.</li>
        <li>Innerhalb von <code>__init__</code> werden Objektvariablen definiert, z. B.:
            <code>self.__name = name</code>, <code>self.__level = level</code>, <code>self.__lebenspunkte = 42</code>.
        </li>
        <li><strong>Objektmethoden</strong> wie <code>vorstellen(self)</code> geben Informationen über das Pokémon aus.</li>
        <li>Die Attribute werden mit <code>self.</code> angesprochen und bleiben dank <code>__</code> geschützt.</li>
        <li>Instanziierung erfolgt durch <code>p1 = Pokemon("Bisasam", 0)</code>.</li>
        <li>Methode <code>get_level()</code> gibt das Level zurück – Zugriff auf geschützte Variablen via Getter-Methoden.</li>
    </ul>

    <h3>Teil 2: Interaktion und Angriffe</h3>
    <ul>
        <li>Neue Methode <code>zeige_level(self)</code> zeigt den Namen + Level kombiniert an.</li>
        <li><code>entwickeln(self)</code> erhöht das Level des Pokémon um 1.</li>
        <li>Ein Angriff wird mit <code>attackieren(self, other, schaden)</code> umgesetzt.</li>
        <li>Der Parameter <code>other</code> steht für das Pokémon, das angegriffen wird.</li>
        <li>Beispiel:
            <pre><code>p1.attackieren(p2, 10)</code></pre>
            zieht dem Pokémon <code>p2</code> 10 Lebenspunkte ab.
        </li>
        <li>Die Methode <code>zeige_lebenspunkte()</code> gibt aktuelle HP aus.</li>
        <li>Da der Zugriff innerhalb derselben Klasse erfolgt, kann auch auf <code>__lebenspunkte</code> von <code>other</code> zugegriffen werden.</li>
        <li>Ein vollständiger Ablauf: Pokémon werden instanziiert, entwickelt, und greifen sich gegenseitig an – und das alles auf Basis von Python OOP.</li>
    </ul>
</section>
<section>
  <h2>18. Magische Methoden in Python – Pokémon</h2>

  <h3>Teil 1: <code>__str__()</code> – Menschlich lesbare Ausgabe</h3>
  <ul>
    <li>Magische Methoden beginnen und enden mit doppelten Unterstrichen (z. B. <code>__str__</code>).</li>
    <li><code>__str__(self)</code> wird aufgerufen, wenn ein Objekt z. B. mit <code>print(obj)</code> ausgegeben wird.</li>
    <li>Beispiel-Implementierung für Pokémon:
      <pre><code>def __str__(self):
    return f"Name: {self.__name}\nLebenspunkte: {self.__lebenspunkte}\nLevel: {self.__level}"</code></pre>
    </li>
    <li>Ergebnis: Menschlich lesbare Darstellung wie:
      <pre>Name: Pikachu
Lebenspunkte: 42
Level: 2</pre>
    </li>
  </ul>

  <h3>Teil 2: <code>__gt__()</code> – Vergleichsoperator &gt;</h3>
  <ul>
    <li><code>__gt__(self, other)</code> vergleicht zwei Objekte mit dem Größer-als-Zeichen.</li>
    <li>Vergleich erfolgt z. B. anhand des Levels:
      <pre><code>def __gt__(self, other):
    return self.__level > other.__level</code></pre>
    </li>
    <li>Verwendung im Hauptprogramm: <code>if p1 &gt; p2:</code> prüft, ob <code>p1</code> ein höheres Level hat als <code>p2</code>.</li>
    <li>Ausgabe ist <code>True</code> oder <code>False</code> je nach Vergleich.</li>
  </ul>

  <h3>Weitere wichtige magische Methoden:</h3>
  <ul>
    <li><code>__add__</code> → für <code>+</code> Operator</li>
    <li><code>__sub__</code> → für <code>-</code> Operator</li>
    <li><code>__mul__</code> → für <code>*</code> Operator</li>
    <li><code>__eq__</code> → für <code>==</code> Gleichheit</li>
    <li><code>__lt__</code> → für <code>&lt;</code> Kleiner-als</li>
  </ul>

  <p>🔁 Durch magische Methoden wird Python-Code intuitiver und klarer lesbar – besonders bei Klassen wie Pokémon!</p>
</section>
<section>
    <h2>18. Fehlerbehandlung mit <code>try</code> und <code>except</code></h2>
    <ul>
        <li>Mit <code>try</code> wird ein Codeblock getestet, der zu Fehlern führen kann.</li>
        <li>Mit <code>except</code> werden bestimmte Fehler (z. B. <code>IndexError</code>, <code>ValueError</code>) gezielt abgefangen.</li>
        <li>Syntax:
            <pre><code>try:
    # kritischer Code
except FehlerTyp:
    # Fehlerbehandlung</code></pre>
        </li>
        <li><code>except Exception as ex</code> fängt alle Fehler ab und speichert sie in <code>ex</code>.</li>
        <li>Beispiel:
            <pre><code>try:
    index = int(input("Index: "))
    print(liste[index])
except IndexError:
    print("Index existiert nicht.")
except ValueError:
    print("Bitte Zahl eingeben.")
except Exception as ex:
    print("Fehler:", ex)</code></pre>
        </li>
        <li>🔁 Vorteil: Das Programm wird bei Fehlern nicht abgebrochen.</li>
        <li>⚠️ Best Practice: Möglichst gezielte Fehlerbehandlung, kein allgemeiner <code>except</code> im Produktivcode.</li>
    </ul>
</section>
<section>
    <h2>19. <code>finally</code> – Code immer ausführen, egal ob Fehler oder nicht</h2>
    <ul>
        <li><code>finally</code> wird nach allen <code>except</code>-Blöcken ausgeführt – immer!</li>
        <li>Nutzen: Ressourcen freigeben, Dateien schließen, Logs schreiben etc.</li>
        <li>Syntax:
            <pre><code>try:
    # kritischer Code
except Exception:
    # Fehlerbehandlung
finally:
    # wird immer ausgeführt</code></pre>
        </li>
        <li>💡 Typisches Beispiel: Datei schließen, egal ob Fehler:
            <pre><code>try:
    f = open("test.txt", "w")
    f.write("Hallo Welt")
except Exception:
    pass
finally:
    f.close()</code></pre>
        </li>
        <li><code>finally</code> ersetzt nicht den <code>except</code> – beide sollten kombiniert werden.</li>
        <li>Empfehlung: In einfachen Fällen nutze den <code>with</code>-Kontextmanager (z. B. <code>with open() as f:</code>).</li>
    </ul>
</section>
</body>

</html>