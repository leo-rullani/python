<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Hinweise zu Python</title>
</head>

<body>
    <h1>Hinweise zu Python</h1>

    <section>
        <h2>1. Variablen</h2>
        <ul>
            <li>Variablen speichern Werte. Zuweisung erfolgt mit <code>=</code>.</li>
            <li>Beispiel: <code>name = "Anna"</code> oder <code>age = 25</code>.</li>
            <li>Mehrere Zuweisungen mÃ¶glich: <code>name, age = "Lisa", 30</code>.</li>
            <li>Werte tauschen: <code>name, age = age, name</code>.</li>
            <li>Variablennamen dÃ¼rfen nicht mit Zahlen beginnen, keine Sonderzeichen oder Keywords.</li>
            <li>GroÃŸ-/Kleinschreibung ist relevant: <code>name â‰  Name</code>.</li>
            <li>Vermeide â€Magic Numbersâ€œ â€“ nutze stattdessen Variablen mit Bedeutung.</li>
        </ul>
    </section>

    <section>
        <h2>2. Datentypen</h2>
        <ul>
            <li>Python erkennt Datentypen automatisch (z.â€¯B. <code>str</code>, <code>int</code>, <code>float</code>,
                <code>bool</code>).</li>
            <li>Mit <code>type(var)</code> kannst du den Typ prÃ¼fen.</li>
            <li>Umwandlungen:
                <ul>
                    <li><code>str(25)</code> â†’ "25"</li>
                    <li><code>int("27")</code> â†’ 27</li>
                    <li><code>float("2.4")</code> â†’ 2.4</li>
                    <li><code>bool("")</code> â†’ False, <code>bool("abc")</code> â†’ True</li>
                </ul>
            </li>
            <li>Fehler bei ungÃ¼ltiger Umwandlung: z.â€¯B. <code>int("27 Jahre")</code> â†’ <code>ValueError</code>.</li>
            <li>0, 0.0, "" gelten als <code>False</code>, alle anderen Werte als <code>True</code>.</li>
        </ul>
    </section>

    <section>
        <h2>3. Umgebungsvariablen</h2>
        <ul>
            <li>Systemvariablen wie <code>PATH</code> oder <code>USER</code>.</li>
            <li>Zugriff in Python Ã¼ber <code>os.environ["NAME"]</code>.</li>
            <li><code>python-dotenv</code> ermÃ¶glicht das Einlesen einer <code>.env</code>-Datei.</li>
            <li><code>.env</code>-Datei enthÃ¤lt Key-Value-Paare, z.â€¯B. <code>USER_NAME=leo</code>.</li>
            <li><code>.env</code> gehÃ¶rt in die <code>.gitignore</code>.</li>
        </ul>
    </section>

    <section>
        <h2>4. Strings definieren</h2>
        <ul>
            <li>Strings mit <code>"Text"</code> oder <code>'Text'</code> definieren.</li>
            <li>Dreifache AnfÃ¼hrungszeichen <code>""" """</code> fÃ¼r mehrzeilige Strings.</li>
            <li>Empfehlung:
                <ul>
                    <li>Ein Zeichen: <code>'A'</code></li>
                    <li>Mehrere Zeichen: <code>"Hallo"</code></li>
                    <li>Leerer String: <code>""</code></li>
                </ul>
            </li>
            <li>Mehrzeilige Strings behalten Formatierung â€“ ideal fÃ¼r ASCII-Art oder Konsolenprogramme.</li>
        </ul>
    </section>

    <section>
        <h2>5. Zeichenzugriff & Substrings</h2>
        <ul>
            <li>Zeichenzugriff mit <code>string[index]</code>.</li>
            <li>Index beginnt bei 0: <code>name[2]</code> â†’ drittes Zeichen.</li>
            <li>Negative Indizes zÃ¤hlen von hinten: <code>-1</code> = letztes Zeichen.</li>
            <li><code>len(string)</code> gibt die LÃ¤nge zurÃ¼ck.</li>
            <li><code>string[len(string)-1]</code> â†’ letztes Zeichen.</li>
            <li>Fehlzugriff auÃŸerhalb des Bereichs fÃ¼hrt zu <code>IndexError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>6. Slicing</h2>
        <ul>
            <li>Slicing-Syntax: <code>string[start:end]</code> â€“ <code>end</code> ist exklusiv.</li>
            <li><code>string[0:3]</code> â†’ erste 3 Zeichen.</li>
            <li><code>string[:5]</code> â†’ von Anfang bis Index 4.</li>
            <li><code>string[3:]</code> â†’ ab Index 3 bis zum Ende.</li>
            <li><code>string[:]</code> â†’ gesamter String.</li>
            <li>Negative Indizes funktionieren auch: <code>string[-3:-1]</code> â†’ vorletzte 2 Zeichen.</li>
            <li>Start- und Endindex auÃŸerhalb der Grenzen sind erlaubt (keine Fehler).</li>
        </ul>
    </section>

    <section>
        <h2>7. Arithmetische Operatoren mit Strings</h2>
        <ul>
            <li><code>+</code> verkettet Strings (z.â€¯B. <code>"a" + "b"</code> â†’ "ab").</li>
            <li><code>*</code> dupliziert Strings (z.â€¯B. <code>"!" * 3</code> â†’ "!!!").</li>
            <li>Reihenfolge bei <code>*</code> egal: <code>3 * "a" == "a" * 3</code>.</li>
            <li>Nur Kombination <code>String * int</code> ist erlaubt â€“ nicht <code>String * String</code> oder
                <code>String - String</code>.</li>
            <li>Potenzieren mit <code>**</code> sowie Division <code>/</code> ist bei Strings nicht erlaubt.</li>
            <li>FehlerfÃ¤lle wie <code>"a" - "b"</code> oder <code>"a" ** 2</code> â†’ <code>TypeError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>8. String-Methoden</h2>
        <ul>
            <li><code>upper()</code>, <code>lower()</code>, <code>capitalize()</code> â€“ Buchstaben umwandeln.</li>
            <li><code>isupper()</code>, <code>islower()</code>, <code>isnumeric()</code>, <code>isalpha()</code> â€“
                RÃ¼ckgabe von <code>True</code> oder <code>False</code>.</li>
            <li><code>split(sep)</code>, <code>splitlines()</code> â€“ Zerlegen von Strings in Listen.</li>
            <li><code>strip()</code> â€“ entfernt Leerzeichen am Anfang/Ende.</li>
            <li><code>replace(old, new)</code> â€“ ersetzt Zeichen oder Substrings.</li>
            <li><code>count(sub)</code> â€“ zÃ¤hlt Vorkommen eines Zeichens/Substrings.</li>
            <li><code>index(sub)</code> â€“ Position des ersten Auftretens, Fehler bei Nichtfund.</li>
            <li><code>find(sub)</code> â€“ wie <code>index()</code>, aber ohne Fehler (liefert <code>-1</code>).</li>
            <li><code>"sub" in string</code> â€“ prÃ¼ft, ob Substring enthalten ist â†’ <code>True</code> oder
                <code>False</code>.</li>
        </ul>
    </section>

    <section>
        <h2>9. Anwendungsbeispiele & Aufgaben zu String-Methoden</h2>
        <ul>
            <li><code>upper()</code> wandelt alle Buchstaben in GroÃŸbuchstaben um.</li>
            <li><code>lower()</code> macht alle Buchstaben klein.</li>
            <li><code>capitalize()</code> schreibt nur den ersten Buchstaben groÃŸ, Rest klein.</li>
            <li><code>zfill(n)</code> fÃ¼llt einen String mit fÃ¼hrenden Nullen auf LÃ¤nge <code>n</code> auf.</li>
            <li><code>islower()</code> / <code>isupper()</code> prÃ¼fen, ob alle Buchstaben klein/groÃŸ sind.</li>
            <li><code>isalpha()</code> prÃ¼ft, ob nur Buchstaben enthalten sind.</li>
            <li><code>isnumeric()</code> prÃ¼ft, ob nur Ziffern enthalten sind.</li>
            <li><code>split(";")</code> trennt einen String anhand eines Trennzeichens (liefert Liste).</li>
            <li><code>replace("alt", "neu")</code> ersetzt Teilstrings gezielt.</li>
            <li><code>count("x")</code> zÃ¤hlt Vorkommen eines Zeichens oder Substrings.</li>
            <li><code>find("x")</code> liefert Index oder <code>-1</code>, wenn nicht gefunden.</li>
            <li><code>index("x")</code> wie <code>find</code>, aber mit Fehler bei Nichtfund.</li>
            <li><code>"x" in string</code> prÃ¼ft, ob <code>x</code> im String enthalten ist.</li>
            <li><code>string[::-1]</code> kehrt einen String um (Reversal per Slicing).</li>
        </ul>
    </section>

    <!-- Arithmetische Operatoren in Python -->
    <section id="arithmetische-operatoren">
        <h2>ğŸ§® Arithmetische Operatoren in Python</h2>
        <p>Hier siehst du eine Ãœbersicht typischer Rechenoperationen und deren Verhalten in Python:</p>

        <h3>1. Grundrechenarten</h3>
        <ul>
            <li><code>12 * 12</code> â†’ <strong>144</strong></li>
            <li><code>2.5 + 3.5</code> â†’ <strong>6.0</strong> (Float + Float = Float)</li>
            <li><code>20 / 5</code> â†’ <strong>4.0</strong> (Division liefert immer Float)</li>
            <li><code>15 - 3 * 5</code> â†’ <strong>0</strong> (Punktrechnung vor Strichrechnung)</li>
        </ul>

        <h3>2. Integer Division <code>//</code></h3>
        <ul>
            <li><code>8 + 10 // 4</code> â†’ <strong>10</strong></li>
            <li><code>8 + 10 / 4</code> â†’ <strong>10.5</strong></li>
            <li><code>20 / (5 - 4)</code> â†’ <strong>20.0</strong></li>
        </ul>

        <h3>3. Kombinationen & Reihenfolge</h3>
        <ul>
            <li><code>4 * 2.5 / 4</code> â†’ <strong>2.5</strong> (Links-nach-rechts-Auswertung)</li>
            <li><code>1 // 2 - 3 // 4</code> â†’ <strong>0</strong></li>
        </ul>

        <h3>4. Modulo <code>%</code></h3>
        <ul>
            <li><code>12 % 5</code> â†’ <strong>2</strong></li>
            <li><code>5 % 12</code> â†’ <strong>5</strong></li>
        </ul>

        <h3>5. Potenzen <code>**</code></h3>
        <ul>
            <li><code>2 ** 3</code> â†’ <strong>8</strong></li>
            <li><code>4 ** (8 - 5)</code> â†’ <strong>64</strong></li>
            <li><code>2 ** 8 // 2</code> â†’ <strong>128</strong></li>
            <li><code>5 ** 2 * 3</code> â†’ <strong>75</strong></li>
        </ul>

        <h3>6. String-Operationen</h3>
        <ul>
            <li><code>"Apfel" + "Baum"</code> â†’ <strong>"ApfelBaum"</strong></li>
            <li><code>5 * ("a" + "b")</code> â†’ <strong>"ababababab"</strong></li>
            <li><code>"x" * 2 ** 3</code> â†’ <strong>"xxxxxxxx"</strong></li>
        </ul>

        <h3>7. SonderfÃ¤lle</h3>
        <ul>
            <li><code>42 % 43</code> â†’ <strong>42</strong></li>
            <li><code>1024 % 2</code> â†’ <strong>0</strong></li>
            <li><code>5 * 4 * 3 * 2 * 1.0</code> â†’ <strong>120.0</strong></li>
            <li><code>0 * "Flo"</code> â†’ <strong>""</strong> (leerer String)</li>
            <li><code>"XYZ" * (12 % 5)</code> â†’ <strong>"XYZXYZ"</strong></li>
        </ul>
    </section>

    <section>
        <h2>11. Inkrementieren, Dekrementieren & Kurzschreibweisen</h2>
        <ul>
            <li>Python kennt keine <code>i++</code> oder <code>i--</code> Operatoren wie in C/Java.</li>
            <li>Stattdessen: kombinierte Zuweisungsoperatoren verwenden.</li>
            <li>Beispiele:
                <ul>
                    <li><code>i += 1</code> â†’ ErhÃ¶he <code>i</code> um 1</li>
                    <li><code>i -= 1</code> â†’ Verringere <code>i</code> um 1</li>
                    <li><code>i *= 2</code> â†’ Multipliziere <code>i</code> mit 2</li>
                    <li><code>i /= 2</code> â†’ Division mit float-Ergebnis</li>
                    <li><code>i //= 2</code> â†’ Ganzzahldivision (Integer)</li>
                    <li><code>i **= 2</code> â†’ Quadrat von <code>i</code></li>
                    <li><code>i %= 3</code> â†’ Rest bei Division durch 3</li>
                </ul>
            </li>
            <li>Die Kurzform spart Wiederholung der Variable und verbessert Lesbarkeit.</li>
        </ul>
    </section>
    <section>
        <h2>12. Vergleichsoperatoren</h2>
        <ul>
            <li>Vergleichsoperatoren geben immer <code>True</code> oder <code>False</code> zurÃ¼ck.</li>
            <li>VerfÃ¼gbare Operatoren:
                <ul>
                    <li><code>a < b</code> â†’ kleiner als</li>
                    <li><code>a <= b</code> â†’ kleiner oder gleich</li>
                    <li><code>a == b</code> â†’ gleich</li>
                    <li><code>a != b</code> â†’ ungleich</li>
                    <li><code>a > b</code> â†’ grÃ¶ÃŸer als</li>
                    <li><code>a >= b</code> â†’ grÃ¶ÃŸer oder gleich</li>
                </ul>
            </li>
            <li>Funktioniert mit Zahlen, Strings (alphabetisch) und spÃ¤ter auch mit Objekten.</li>
            <li>Beispiel:
                <code>"Flo" < "Florian"</code> â†’ <code>True</code> (wegen alphabetischer Ordnung)
            </li>
            <li>Alle Vergleichsoperatoren haben die gleiche BindungsstÃ¤rke und werden von links nach rechts ausgewertet.
            </li>
        </ul>
    </section>

    <section>
        <h2>13. Logische Operatoren</h2>
        <ul>
            <li>VerknÃ¼pfen Wahrheitswerte (<code>True</code> oder <code>False</code>).</li>
            <li>Ergebnisse sind stets <code>True</code> oder <code>False</code>.</li>
            <li>Operatoren:
                <ul>
                    <li><code>and</code> â†’ nur <code>True</code>, wenn beide Bedingungen <code>True</code> sind.</li>
                    <li><code>or</code> â†’ <code>True</code>, wenn mindestens eine Bedingung <code>True</code> ist.</li>
                    <li><code>not</code> â†’ kehrt den Wahrheitswert um.</li>
                    <li><code>^</code> (XOR) â†’ <code>True</code>, wenn genau eine Bedingung <code>True</code> ist.</li>
                </ul>
            </li>
            <li>Beispiele:
                <ul>
                    <li><code>2 &lt; 3 and 3 &lt; 5</code> â†’ <code>True</code></li>
                    <li><code>not (3 == 5)</code> â†’ <code>True</code></li>
                    <li><code>True ^ False</code> â†’ <code>True</code></li>
                </ul>
            </li>
            <li>Operatorrangfolge:
                <ul>
                    <li><strong>1.</strong> <code>not</code></li>
                    <li><strong>2.</strong> <code>and</code></li>
                    <li><strong>3.</strong> <code>or</code></li>
                </ul>
            </li>
            <li>Nutze <code>()</code>, um Auswertungsreihenfolge gezielt zu steuern.</li>
        </ul>
    </section>

    <section>
        <h2>14. Logik-Aufgaben & Kombinationen</h2>
        <ul>
            <li><strong>Operatoren:</strong> <code>and</code>, <code>or</code>, <code>not</code>, <code>^</code> (XOR).
            </li>
            <li><strong>Ergebnisse:</strong> Immer <code>True</code> oder <code>False</code>.</li>
            <li><strong>Operatorrangfolge:</strong>
                <ul>
                    <li><code>not</code> bindet am stÃ¤rksten</li>
                    <li><code>and</code> folgt</li>
                    <li><code>or</code> danach</li>
                    <li><code>^</code> (XOR) ist ein bitweiser Operator mit hoher Bindung</li>
                </ul>
            </li>
            <li><strong>Verwendung in Bedingungen:</strong> Vergleichs- und arithmetische Operatoren werden zuerst
                ausgewertet, danach logische Operatoren.</li>
            <li><strong>Beispiele:</strong>
                <ul>
                    <li><code>True and False or True</code> â†’ <code>True</code></li>
                    <li><code>not False</code> â†’ <code>True</code></li>
                    <li><code>True ^ True</code> â†’ <code>False</code></li>
                    <li><code>2 % 5 == 2</code> â†’ <code>True</code></li>
                    <li><code>not not not (2 % 5 == 2)</code> â†’ <code>False</code></li>
                </ul>
            </li>
            <li><strong>Unterschied:</strong>
                <ul>
                    <li><code>or</code>: beides darf <code>True</code> sein (z.â€¯B. â€Milch oder Zuckerâ€œ)</li>
                    <li><code>^</code>: nur eins darf <code>True</code> sein (â€entweder Big Mac oder Big Tastyâ€œ)</li>
                </ul>
            </li>
            <li><strong>Mix mit Zahlen:</strong> <code>True ^ 0</code> ergibt <code>1</code> (kein Boolean, sondern
                Integer!)</li>
        </ul>
    </section>

    <section>
        <h2>15. Operatorrangfolge</h2>
        <p>Die folgende Tabelle zeigt die Reihenfolge, in der Operatoren in Python ausgewertet werden (von oben nach
            unten â€“ hÃ¶chste zu niedrigster Bindung):</p>
        <table border="1" cellpadding="6" cellspacing="0">
            <thead>
                <tr>
                    <th>PrioritÃ¤t</th>
                    <th>Operator(en)</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td><code>**</code></td>
                    <td>Potenz (Exponentiation)</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
                    <td>Multiplikation, Division, ganzzahlige Division, Modulo</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><code>+</code>, <code>-</code></td>
                    <td>Addition, Subtraktion</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td><code>^</code></td>
                    <td>Bitweises XOR (zÃ¤hlt technisch zu bitweisen Operatoren)</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>,
                        <code>&gt;</code></td>
                    <td>Vergleichsoperatoren</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td><code>not</code></td>
                    <td>Logische Negation</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td><code>and</code></td>
                    <td>Logisches UND</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td><code>or</code></td>
                    <td>Logisches ODER (schwÃ¤chste Bindung)</td>
                </tr>
            </tbody>
        </table>
        <p>Tipp: Wenn du eine andere Reihenfolge erzwingen willst, nutze Klammern <code>()</code>.</p>
    </section>
    <section>
        <h2>11. If-Anweisung</h2>
        <ul>
            <li><code>if</code> prÃ¼ft eine Bedingung und fÃ¼hrt Code nur aus, wenn sie <code>True</code> ergibt.</li>
            <li>Syntax:
                <pre><code>if BEDINGUNG:
    # tue etwas
else:
    # tue etwas anderes</code></pre>
            </li>
            <li>Vergleich mit <code>==</code>, nicht mit <code>=</code> (Zuweisung!).</li>
            <li>EinrÃ¼ckung nach dem <code>:</code> ist zwingend (meist 4 Leerzeichen).</li>
            <li><code>else</code> ist optional, darf aber nur mit passendem <code>if</code> verwendet werden.</li>
            <li>Beispiel:
                <pre><code>passwort = input("Gib dein Passwort ein:")
if passwort == "ABC123":
    print("Das Passwort ist korrekt.")
else:
    print("Das Passwort ist nicht korrekt.")</code></pre>
            </li>
        </ul>
    </section>
    <section>
    <h2>12. Mehrfache Bedingungen mit <code>elif</code></h2>
    <ul>
        <li><code>elif</code> steht fÃ¼r â€else ifâ€œ â€“ wird geprÃ¼ft, wenn die <code>if</code>-Bedingung nicht zutrifft.</li>
        <li><code>else</code> fÃ¤ngt alle Ã¼brigen FÃ¤lle auf, wenn keine vorherige Bedingung zutrifft.</li>
        <li>Nur der erste passende Block wird ausgefÃ¼hrt â€“ danach wird der Rest ignoriert.</li>
        <li>Syntax:
            <pre><code>if BEDINGUNG:
    ANWEISUNG
elif ANDERE_BEDINGUNG:
    ANWEISUNG
else:
    ANWEISUNG</code></pre>
        </li>
        <li>Beispiel:
            <pre><code>note = input("Gib die Schulnote ein (1â€“6): ")

if note == "1":
    print("Sehr gut!")
elif note == "2":
    print("Gut")
elif note == "3":
    print("Befriedigend")
elif note == "4":
    print("Ausreichend")
elif note == "5":
    print("Mangelhaft")
elif note == "6":
    print("UngenÃ¼gend")
else:
    print("UngÃ¼ltige Eingabe")</code></pre>
        </li>
        <li>Tipp: FÃ¼r numerische Eingaben <code>int()</code> verwenden:
            <pre><code>note = int(input("Gib die Schulnote als Zahl ein: "))</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>10. Match-Case (ab Python 3.10)</h2>
    <ul>
        <li><code>match</code> prÃ¼ft den Wert einer Variable gegen mehrere <code>case</code>-FÃ¤lle.</li>
        <li>Ã„hnlich wie <code>switch-case</code> in anderen Sprachen, aber leistungsfÃ¤higer.</li>
        <li><code>case _</code> entspricht einem <code>else</code>-Zweig â€“ wird ausgefÃ¼hrt, wenn kein anderer <code>case</code> passt.</li>
        <li>Beispiel mit Strings:
            <pre><code>match note:
    case "1":
        print("Sehr gut!")
    case "2":
        print("Gut")
    case _:
        print("UngÃ¼ltige Eingabe.")</code></pre>
        </li>
        <li>Auch mit <code>int</code> mÃ¶glich â€“ z.â€¯B. <code>match int(note):</code></li>
        <li>Erweiterbar auf Listen, Tupel oder eigene Objekte (Pattern Matching).</li>
    </ul>
</section>

<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen CodeblÃ¶cke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird â€“ sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen CodeblÃ¶cke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird â€“ sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>12. For-Schleifen</h2>
    <ul>
        <li>Eine <code>for</code>-Schleife wird verwendet, um eine definierte Anzahl an DurchlÃ¤ufen Ã¼ber eine Datenstruktur (z.â€¯B. Liste, Tupel, <code>range()</code>) durchzufÃ¼hren.</li>
        <li><code>for element in iterable:</code> â†’ Jeder Eintrag wird nacheinander der Variablen zugewiesen.</li>
        <li>Beispiel:
            <pre><code>passwoerter = ["abc123", "geheim", "test", "123456"]
for passwort in passwoerter:
    print(passwort)</code></pre>
        </li>
        <li><code>break</code> bricht die Schleife vorzeitig ab, z.â€¯B. bei einer Abbruchbedingung:
            <pre><code>if len(passwort) &lt; 5:
    break</code></pre>
        </li>
        <li>Funktioniert mit Listen, Tupeln, Sets, Dictionaries, Strings & <code>range()</code>.</li>
        <li>Besonders leserlich durch Python's iterator-basierten Ansatz.</li>
    </ul>
</section>
<section>
    <h2>13. Endlosschleifen</h2>
    <p>Endlosschleifen entstehen, wenn eine <code>while</code>-Schleife nie endet, weil ihre Bedingung dauerhaft <code>True</code> bleibt.</p>
    <p>Beispiel einer fehlerhaften <code>while</code>-Schleife:</p>
    <pre><code>teilnehmer = input("Teilnehmer eingeben: ")
teilnehmer_liste = []

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    # Eingabe fehlt hier â†’ Endlosschleife</code></pre>
    <p><strong>Richtig:</strong> Eingabe innerhalb der Schleife erneut abfragen:</p>
    <pre><code>teilnehmer_liste = []
teilnehmer = input("Teilnehmer eingeben (X zum Beenden): ")

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    teilnehmer = input("NÃ¤chster Teilnehmer (X zum Beenden): ")</code></pre>
    <p>Alternativ mit <code>while True</code> und <code>break</code> absichern:</p>
    <pre><code>i = 0
while True:
    if i == 3:
        break
    print("Durchlauf", i)
    i += 1</code></pre>
    <p>ğŸ’¡ Achte darauf, dass sich die Bedingung in der Schleife irgendwann Ã¤ndert â€“ sonst lÃ¤uft sie unendlich weiter.</p>
</section>

<section>
  <h2>14. Unterschied: for vs. while</h2>
  <p>ğŸ” Python kennt zwei Haupt-Schleifentypen:</p>
  <ul>
    <li><strong><code>for</code>-Schleife:</strong> Wiederholt einen Codeblock <em>eine festgelegte Anzahl an Malen</em> â€“ typischerweise Ã¼ber Datenstrukturen wie Listen, Tupel oder Strings.</li>
    <li><strong><code>while</code>-Schleife:</strong> Wiederholt den Codeblock <em>solange eine Bedingung wahr ist</em> â€“ die Laufzeit ist also abhÃ¤ngig von Benutzeraktionen oder Programmlogik.</li>
  </ul>

  <h3>ğŸ§  Vergleich</h3>
  <table>
    <thead>
      <tr>
        <th>Eigenschaft</th>
        <th><code>for</code>-Schleife</th>
        <th><code>while</code>-Schleife</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>â³ Laufzeit</td>
        <td>Vordefiniert (z.&nbsp;B. durch LÃ¤nge einer Liste)</td>
        <td>AbhÃ¤ngig von einer Bedingung</td>
      </tr>
      <tr>
        <td>ğŸ“¦ Typischer Einsatz</td>
        <td>Datenstrukturen durchlaufen</td>
        <td>Benutzereingaben, Event Loops, Server-Ãœberwachung</td>
      </tr>
      <tr>
        <td>âŒ Endlosschleifen mÃ¶glich?</td>
        <td>Nein (endet automatisch nach X DurchlÃ¤ufen)</td>
        <td>Ja (z.&nbsp;B. durch <code>while True</code>)</td>
      </tr>
      <tr>
        <td>ğŸ”§ Benutzerabbruch</td>
        <td>Nur mit <code>break</code> bei zusÃ¤tzlicher PrÃ¼fung</td>
        <td>Einfach durch Eingabebedingung steuerbar</td>
      </tr>
    </tbody>
  </table>

  <p>ğŸ’¡ <strong>Fazit:</strong> Verwende <code>for</code>, wenn die Anzahl der DurchlÃ¤ufe bekannt ist (z.&nbsp;B. Liste, String, range), und <code>while</code>, wenn du flexibel auf Bedingungen oder Benutzereingaben reagieren musst.</p>
</section>
<section>
  <h2>15. Walross-Operator <code>:=</code></h2>
  <p>
    Seit Pythonâ€¯3.8 gibt es den sogenannten <strong>Walross-Operator</strong> <code>:=</code> (auch â€<em>assignment expression</em>â€œ genannt).
    Er erlaubt, einer Variablen innerhalb einer Bedingung <em>einen Wert zuzuweisen und diesen gleichzeitig zu prÃ¼fen</em> â€“ ideal fÃ¼r kompakte, lesbare Schleifen.
  </p>

  <h3>ğŸ“š Beispiel: Teilnehmerliste mit <code>while</code>-Schleife</h3>
  <pre><code>teilnehmerliste = []

while (teilnehmer := input("Gib einen Teilnehmer ein: ")) != "x":
    teilnehmerliste.append(teilnehmer)

print("Teilnehmerliste:", teilnehmerliste)</code></pre>

  <h3>ğŸ§  Vorteile:</h3>
  <ul>
    <li>Vermeidet doppelte Codezeilen wie <code>input(...)</code> vor und in der Schleife.</li>
    <li>ErhÃ¶ht die Lesbarkeit & reduziert Fehler durch Copy-Paste.</li>
    <li>Perfekt fÃ¼r kompakte while-Bedingungen mit Zuweisung.</li>
  </ul>

  <p>ğŸ’¡ Merkhilfe: Der Operator <code>:=</code> sieht aus wie das Gesicht eines ğŸ¦­â€¯Walrosses â€“ daher der Name.</p>
</section>
<section>
  <h2>16. Listen in Python</h2>
  <ul>
    <li>Listen sind <strong>flexibel</strong> und <strong>dynamisch</strong>: Sie kÃ¶nnen verschiedene Datentypen enthalten (z.â€¯B. <code>int</code>, <code>str</code>, <code>bool</code>).</li>
    <li>Erstellung: <code>liste = []</code> (leere Liste) oder z.â€¯B. <code>liste = [42, "Florian", True]</code></li>
    <li>LÃ¤nge ermitteln mit <code>len(liste)</code></li>
    <li>Zugriff Ã¼ber Index: <code>liste[0]</code>, <code>liste[-1]</code> (letztes Element)</li>
    <li><strong>Slicing</strong>: <code>liste[1:4]</code> â€“ liefert eine Teilliste (Start inkl., Ende exkl.)</li>
    <li>Out-of-Range beim <strong>Slicing</strong> ist erlaubt â†’ kein Fehler.</li>
    <li>Out-of-Range bei direktem Indexzugriff (<code>liste[99]</code>) fÃ¼hrt zu <code>IndexError</code>.</li>
  </ul>
</section>
<section>
  <h2>Kapitel 17 â€“ Listenmethoden</h2>
  <p>Listen sind dynamische Datenstrukturen in Python, die Elemente verschiedenster Typen aufnehmen kÃ¶nnen. Sie bieten eine Vielzahl an Methoden zur Bearbeitung.</p>

  <h3>Elemente hinzufÃ¼gen</h3>
  <ul>
    <li><code>+</code> zum Verketten von Listen</li>
    <li><code>*</code> zur Wiederholung von Listen</li>
    <li><code>.append(wert)</code> â€“ HÃ¤ngt ein einzelnes Element an</li>
    <li><code>.insert(index, wert)</code> â€“ FÃ¼gt ein Element an gegebener Position ein</li>
  </ul>

  <h3>Elemente entfernen</h3>
  <ul>
    <li><code>.remove(wert)</code> â€“ Entfernt das erste Vorkommen</li>
    <li><code>.clear()</code> â€“ Leert die gesamte Liste</li>
  </ul>

  <h3>Weitere Methoden</h3>
  <ul>
    <li><code>.count(wert)</code> â€“ ZÃ¤hlt, wie oft ein Wert vorkommt</li>
    <li><code>.sort()</code> â€“ Sortiert die Liste (optional: <code>reverse=True</code>)</li>
    <li><code>.copy()</code> â€“ Erstellt eine echte Kopie</li>
    <li><code>.index(wert)</code> â€“ Gibt die erste Indexposition eines Werts zurÃ¼ck</li>
    <li><code>w in liste</code> â€“ PrÃ¼ft, ob <code>w</code> enthalten ist</li>
  </ul>

  <h3>String-Methode <code>.join()</code></h3>
  <p>Wird auf einen String angewendet und verbindet die Elemente einer String-Liste:</p>
  <pre><code>'-'.join(["A", "B", "C"])  # "A-B-C"</code></pre>
</section>
<!-- Tupel in Python -->
<section id="tupel-python">
  <h2>ğŸ“˜ Tupel in Python</h2>
  <p>Tupel sind eine unverÃ¤nderliche Datenstruktur in Python, Ã¤hnlich wie Listen, aber starr.</p>

  <h3>ğŸ§© Eigenschaften</h3>
  <ul>
    <li>UnverÃ¤nderlich: keine Elemente hinzufÃ¼gen, lÃ¶schen oder Ã¤ndern</li>
    <li>Festgelegte LÃ¤nge und Reihenfolge</li>
    <li>Ideal fÃ¼r konstante Werte wie Koordinaten oder FunktionsrÃ¼ckgaben</li>
  </ul>

  <h3>ğŸ§ª Syntax</h3>
  <pre><code>mein_tupel = (1, 2, 3)
leeres_tupel = ()
</code></pre>

  <h3>ğŸ“ LÃ¤nge bestimmen</h3>
  <pre><code>len((1, 2, 3))  # â†’ 3</code></pre>

  <h3>ğŸ¯ Zugriff auf Elemente</h3>
  <pre><code>t = (4, 5, 29, 7)
t[2]    # â†’ 29
t[-2]   # â†’ 29 (von hinten)</code></pre>

  <h3>ğŸ” Direktzugriff ohne Variable</h3>
  <pre><code>print((4, 5, 29, 7)[-2])  # â†’ 29</code></pre>

  <h3>âš™ï¸ Tupel als RÃ¼ckgabe von Funktionen</h3>
  <pre><code>def addieren(a, b):
    return a, b, a + b

ergebnis = addieren(1, 4)
print(ergebnis)        # â†’ (1, 4, 5)
print(type(ergebnis))  # â†’ &lt;class 'tuple'&gt;</code></pre>

  <h3>ğŸ§  *args â†’ automatisch Tupel</h3>
  <pre><code>def addieren(*summanden):
    print(type(summanden))  # â†’ &lt;class 'tuple'&gt;
    return sum(summanden)

addieren(1, 2, 3)  # â†’ 6</code></pre>

  <h3>ğŸ“Œ Merksatz</h3>
  <blockquote>
    Tupel = Liste, die man nicht verÃ¤ndern darf.
  </blockquote>
</section>
<!-- Tupel: Methoden, Kopieren und Umwandeln -->
<section id="tupel-methoden">
  <h2>ğŸ“˜ Tupel: Methoden, Kopieren & Umwandeln</h2>
  <p>Tupel sind unverÃ¤nderliche Datenstrukturen in Python â€“ das bedeutet, dass viele Methoden, die Listen verÃ¤ndern, hier nicht funktionieren.</p>

  <h3>ğŸ”’ Keine Ã„nderungsmethoden</h3>
  <ul>
    <li>Keine <code>append()</code>, <code>remove()</code> etc.</li>
    <li>Keine direkte VerÃ¤nderung des Tupels mÃ¶glich</li>
  </ul>

  <h3>â• Tupel kombinieren</h3>
  <pre><code>t1 = (1, 2, 3)
t2 = (4, 5)
neu = t1 + t2  # â†’ (1, 2, 3, 4, 5)</code></pre>

  <h3>ğŸ” Lesende Methoden</h3>
  <ul>
    <li><code>count()</code> â€“ zÃ¤hlt, wie oft ein Element vorkommt</li>
    <li><code>index()</code> â€“ gibt die Position des ersten Vorkommens zurÃ¼ck</li>
  </ul>
  <pre><code>t = (7, 1, 7, 2)
t.count(7)     # â†’ 2
t.index(1)     # â†’ 1</code></pre>

  <h3>ğŸ§ª Kopieren</h3>
  <ul>
    <li>Zuweisung <code>kopie = original</code> erzeugt einen Verweis</li>
    <li>Kein Problem, da Tupel unverÃ¤nderbar sind</li>
  </ul>

  <h3>ğŸ”„ Sortieren durch Umwandlung</h3>
  <pre><code>t = (5, 2, 8, 1)
liste = list(t)
liste.sort()
print(liste)  # â†’ [1, 2, 5, 8]</code></pre>

  <h3>ğŸ“Œ MerksÃ¤tze</h3>
  <blockquote>
    Tupel erlauben nur lesende Methoden. <br>
    FÃ¼r Sortierung: zuerst in Liste umwandeln!
  </blockquote>
</section>
<!-- Set-Methoden in Python -->
<section id="set-methoden">
  <h2>ğŸ“˜ Set-Methoden in Python</h2>
  <p>Sets sind Mengen ohne Duplikate und ohne feste Reihenfolge. Daher gibt es einige Methoden nicht, aber andere, die gut zu dieser Datenstruktur passen.</p>

  <h3>âŒ Nicht vorhandene Methoden</h3>
  <ul>
    <li><code>count()</code> â€“ nicht verfÃ¼gbar, da keine Duplikate erlaubt sind</li>
    <li><code>index()</code> â€“ nicht verfÃ¼gbar, da Sets keine Reihenfolge haben</li>
  </ul>

  <h3>âœ… Existierende Methoden & Operationen</h3>

  <h4>ğŸ” Vorhandensein prÃ¼fen</h4>
  <pre><code>5 in s  # â†’ True
99 in s # â†’ False</code></pre>

  <h4>â• HinzufÃ¼gen: <code>add()</code></h4>
  <pre><code>s = {1, 2}
s.add(3)  # â†’ {1, 2, 3}</code></pre>

  <h4>â– Entfernen: <code>remove()</code></h4>
  <pre><code>s = {3, 5, 8}
s.remove(8)  # â†’ {3, 5}</code></pre>

  <h4>ğŸ§¹ Alles lÃ¶schen: <code>clear()</code></h4>
  <pre><code>s.clear()  # â†’ set()</code></pre>

  <h4>ğŸ“‹ Kopieren: <code>copy()</code></h4>
  <pre><code>kopie = original.copy()</code></pre>

  <h3>ğŸ”„ Sortieren (indirekt)</h3>
  <pre><code>s = {11, 2, 7}
liste = list(s)
liste.sort()
print(liste)  # â†’ [2, 7, 11]</code></pre>

  <h3>ğŸ“Œ Merksatz</h3>
  <blockquote>
    Sets sind ungeordnet und einzigartig. <br>
    FÃ¼r Sortierung â†’ zuerst in eine Liste umwandeln.
  </blockquote>
</section>
<!-- Dictionaries in Python -->
<section id="dictionaries">
  <h2>ğŸ“˜ Dictionaries in Python â€“ EinfÃ¼hrung & Zugriff</h2>
  <p>Ein Dictionary ist eine Sammlung von SchlÃ¼ssel-Wert-Paaren â€“ vergleichbar mit einem Telefonbuch oder einem echten WÃ¶rterbuch.</p>

  <h3>ğŸ§© Aufbau & Syntax</h3>
  <pre><code>{
  "Yunus": "01234",
  "Florian": "09876"
}</code></pre>
  <ul>
    <li><code>{}</code> â†’ leeres Dictionary</li>
    <li>SchlÃ¼ssel und Werte werden mit <code>:</code> verbunden</li>
    <li>Mehrere Paare werden mit <code>,</code> getrennt</li>
  </ul>

  <h3>ğŸ” Zugriff auf Werte</h3>
  <pre><code>telefonbuch.get("Yunus")      # â†’ "01234"
telefonbuch["Yunus"]          # â†’ "01234"
telefonbuch.get("Unbekannt")  # â†’ None
telefonbuch["Unbekannt"]      # â†’ KeyError!</code></pre>
  <p><strong>Tipp:</strong> Immer <code>get()</code> verwenden, wenn du nicht sicher bist, ob der SchlÃ¼ssel existiert.</p>

  <h3>ğŸ”„ Werte & Typen</h3>
  <ul>
    <li>Werte kÃ¶nnen <code>str</code>, <code>int</code>, <code>list</code> oder andere Objekte sein</li>
    <li>Beispiel: <code>{"Yunus": [0,1,2,3]}</code></li>
  </ul>

  <h3>ğŸ” Erlaubte SchlÃ¼sseltypen</h3>
  <ul>
    <li><strong>Erlaubt:</strong> <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code></li>
    <li><strong>Verboten:</strong> <code>list</code>, <code>set</code>, <code>dict</code> (nicht hashbar)</li>
  </ul>

  <h3>ğŸ“ LÃ¤nge ermitteln</h3>
  <pre><code>len(telefonbuch)  # â†’ Anzahl der EintrÃ¤ge</code></pre>

  <h3>ğŸ“Œ Merksatz</h3>
  <blockquote>
    Dictionaries sind SchlÃ¼ssel-Wert-Speicher. <br>
    Immer <code>get()</code> nutzen, wenn du Fehler vermeiden willst.
  </blockquote>
</section>
<!-- Dictionaries: Zugriff, Update, LÃ¶schen & Methoden -->
<section id="dictionaries-methoden">
  <h2>ğŸ“˜ Dictionaries â€“ Zugriff, Update, LÃ¶schen & Methoden</h2>
  <p>Ein Dictionary speichert SchlÃ¼ssel-Wert-Paare und bietet zahlreiche Methoden fÃ¼r sicheren Zugriff und Bearbeitung.</p>

  <h3>ğŸ” Zugriff auf Werte</h3>
  <ul>
    <li><code>dict["key"]</code> â†’ direkter Zugriff (Achtung: <code>KeyError</code> mÃ¶glich)</li>
    <li><code>dict.get("key")</code> â†’ sicherer Zugriff, gibt <code>None</code> oder optionalen Default zurÃ¼ck</li>
  </ul>
  <pre><code>pw.get("abc123")               # â†’ Wert
pw.get("ultrageheim")         # â†’ None
pw.get("ultrageheim", "...")  # â†’ "...", falls nicht vorhanden</code></pre>

  <h3>ğŸ›  Werte aktualisieren</h3>
  <ul>
    <li><code>dict["key"] = neuer_wert</code> â€“ aktualisiert oder fÃ¼gt neu hinzu</li>
    <li><code>dict.update({"key": neuer_wert})</code> â€“ empfohlene Methode</li>
  </ul>

  <h3>â– EintrÃ¤ge lÃ¶schen</h3>
  <ul>
    <li><code>del dict["key"]</code> â€“ entfernt SchlÃ¼ssel + Wert</li>
    <li><code>dict.clear()</code> â€“ entfernt alle EintrÃ¤ge</li>
  </ul>

  <h3>ğŸ“‹ Dictionary kopieren</h3>
  <pre><code>kopie = original.copy()</code></pre>
  <p>âš ï¸ Nicht nur <code>=</code> verwenden, da das nur eine Referenz erzeugt!</p>

  <h3>ğŸ”‘ SchlÃ¼ssel & ğŸ”“ Werte abrufen</h3>
  <pre><code>keys = dict.keys()
print(list(keys))  # echte Liste aller SchlÃ¼ssel

values = dict.values()
print(list(values))  # echte Liste aller Werte</code></pre>

  <p>Beachte: <code>.keys()</code> & <code>.values()</code> liefern spezielle Objekte wie <code>dict_keys</code>, die per <code>list()</code> umgewandelt werden kÃ¶nnen.</p>

  <h3>ğŸ“Œ MerksÃ¤tze</h3>
  <blockquote>
    Immer <code>.get()</code> statt <code>[]</code> bei unsicherem Zugriff verwenden.<br>
    <code>.update()</code> zum sicheren Ã„ndern.<br>
    <code>.keys()</code> und <code>.values()</code> ggf. mit <code>list()</code> umwandeln.
  </blockquote>
</section>
<!-- Funktionen in Python -->
<section id="funktionen">
  <h2>ğŸ§  Funktionen in Python â€“ Definition, Aufruf & RÃ¼ckgabe</h2>
  <p>Funktionen helfen dir, Code zu strukturieren, wiederverwendbar zu machen und Berechnungen elegant durchzufÃ¼hren.</p>

  <h3>ğŸ”§ Funktionsdefinition</h3>
  <pre><code>def funktionsname(parameter1, parameter2):
    # Anweisungen (z.â€¯B. Berechnungen, Ausgaben)</code></pre>
  <ul>
    <li><code>def</code> â€“ Einleitung der Funktion</li>
    <li>EinrÃ¼ckung statt geschweifter Klammern</li>
    <li>Parameter in Klammern (optional)</li>
  </ul>

  <h3>â–¶ï¸ Aufruf einer Funktion</h3>
  <pre><code>def sag_hallo(name):
    print(f"Hallo {name}")

sag_hallo("Florian")</code></pre>

  <h3>ğŸ“¥ Mehrere Parameter</h3>
  <pre><code>def sag_hallo(vorname, nachname):
    print(f"Hallo {vorname} {nachname}")</code></pre>

  <h3>ğŸ”„ RÃ¼ckgabewerte mit <code>return</code></h3>
  <pre><code>def addieren(a, b):
    summe = a + b
    return summe

ergebnis = addieren(10, 32)
print(f"Summe: {ergebnis}")</code></pre>

  <h3>ğŸ“Œ Wichtige Hinweise</h3>
  <ul>
    <li>RÃ¼ckgabewerte nur per <code>return</code></li>
    <li>Variablen in Funktionen sind <strong>lokal</strong></li>
    <li>Leere Funktionen mit <code>pass</code> definieren</li>
    <li>EinrÃ¼ckung ist <strong>Pflicht</strong> â€“ sie ersetzt <code>{}</code>!</li>
  </ul>

  <blockquote>
    Wiederverwendbarer Code = sauberer Code ğŸ’¡<br>
    Nutze Funktionen fÃ¼r Berechnungen, Ausgaben & Organisation.
  </blockquote>
</section>

<!-- *args und variable Parameter in Python -->
<section id="args-funktionen">
  <h2>ğŸ“¦ *args â€“ Beliebig viele Parameter an Funktionen Ã¼bergeben</h2>
  <p>
    Wenn du nicht im Voraus weiÃŸt, wie viele Werte an eine Funktion Ã¼bergeben werden sollen, kannst du mit <code>*args</code> flexibel bleiben.
  </p>

  <h3>ğŸ¯ Standard-Funktionsdefinition</h3>
  <pre><code>def addieren(a, b):
    return a + b</code></pre>
  <p>
    Problem: Du musst die Anzahl der Parameter <strong>fix vorgeben</strong>.
  </p>

  <h3>ğŸš€ LÃ¶sung mit <code>*args</code></h3>
  <pre><code>def addieren(*summanden):
    return sum(summanden)</code></pre>

  <p>
    Diese Funktion akzeptiert eine <strong>beliebige Anzahl</strong> an Argumenten â€“ sogar keine. Intern wird <code>summanden</code> als <strong>Tuple</strong> gespeichert.
  </p>

  <h3>ğŸ”¢ Beispiel-Aufrufe</h3>
  <pre><code>addieren(1, 2, 3)           # â†’ 6
addieren(10, 20, 30, 40)    # â†’ 100
addieren()                  # â†’ 0</code></pre>

  <h3>ğŸ“Œ Kombination mit fixen Parametern</h3>
  <pre><code>def lotto_spielen(vorname, nachname, *zahlen):
    print(f"Hallo {vorname} {nachname}")
    print("Deine Zahlen lauten:", zahlen)</code></pre>

  <p>Beim Aufruf mÃ¼ssen die fixen Parameter <strong>zuerst</strong> kommen:</p>
  <pre><code>lotto_spielen("Florian", "Deiwick", 4, 8, 15, 16, 23, 42)</code></pre>

  <h3>âŒ Fehlerhafte Reihenfolge</h3>
  <pre><code># FALSCH:
lotto_spielen(4, 8, 15, 16, 23, 42, "Florian", "Deiwick")</code></pre>
  <p>
    â†’ FÃ¼hrt zu einem Fehler, da Python nicht weiÃŸ, welche Werte zu den fixen und welche zu den variablen Parametern gehÃ¶ren.
  </p>

  <h3>ğŸ§  Merksatz</h3>
  <blockquote>
    <strong>Immer zuerst die fixen Parameter</strong> (Positional Arguments),<br>
    danach die variablen Parameter mit <code>*args</code>.
  </blockquote>
</section>
<section id="kwargs">
  <h2>ğŸ§© **kwargs â€“ Variable Keyword-Argumente</h2>
  <p>Mit <code>**kwargs</code> kannst du <strong>beliebig viele benannte Argumente</strong> (SchlÃ¼ssel-Wert-Paare) Ã¼bergeben. Intern wird <code>kwargs</code> als <em>Dictionary</em> gespeichert.</p>

  <h3>ğŸ”§ Definition</h3>
  <pre><code>def info(**daten):
    print(daten)</code></pre>

  <h3>ğŸ“¥ Anwendung</h3>
  <pre><code>info(name="Max", alter=25)
# Ausgabe: {'name': 'Max', 'alter': 25}</code></pre>

  <h3>ğŸ§  Zugriff mit <code>.get()</code></h3>
  <pre><code>def info(**daten):
    name = daten.get("name", "Unbekannt")
    alter = daten.get("alter", 0)
    print(f"{name} ist {alter} Jahre alt.")

info(name="Lena")
# Ausgabe: Lena ist 0 Jahre alt.</code></pre>

  <h3>ğŸ“Œ Eigenschaften</h3>
  <ul>
    <li><code>**kwargs</code> erlaubt <strong>benannte Parameter</strong> in beliebiger Anzahl.</li>
    <li>Reihenfolge ist <strong>egal</strong>.</li>
    <li><code>.get()</code> schÃ¼tzt vor Fehlern bei fehlenden SchlÃ¼sseln.</li>
  </ul>

  <h3>ğŸ“ Standardwerte (Fallback)</h3>
  <pre><code>daten.get("geschlecht", "nicht angegeben")</code></pre>

  <p>Ideal fÃ¼r <strong>flexible Funktionen</strong>, z.â€¯B. Webformulare oder APIs.</p>
</section>
<section id="funktionsreihenfolge">
  <h2>ğŸ”„ Aufrufreihenfolge von Parametern in Python-Funktionen</h2>

  <p>In Python muss beim Definieren von Funktionen eine bestimmte <strong>Reihenfolge der Parameter</strong> eingehalten werden, damit der Funktionsaufruf korrekt funktioniert. Diese Reihenfolge ist besonders wichtig bei Kombinationen aus <code>positional arguments</code>, <code>*args</code> und <code>**kwargs</code>.</p>

  <h3>âœ… Erlaubte Reihenfolge bei der Funktionsdefinition:</h3>
  <ol>
    <li><strong>Positional arguments</strong> (z.â€¯B. <code>name</code>, <code>alter</code>)</li>
    <li><strong><code>*args</code></strong> â€“ fÃ¼r eine <em>beliebige Anzahl an Positionsargumenten</em></li>
    <li><strong><code>**kwargs</code></strong> â€“ fÃ¼r <em>beliebig viele benannte Argumente</em> (SchlÃ¼ssel-Wert-Paare)</li>
  </ol>

  <h3>ğŸ“Œ Beispiel</h3>
  <pre><code>def daten_erfassen(id, vorname, nachname, *geodaten, **daten):
    print(f"ID: {id}")
    print(f"Vorname: {vorname}")
    print(f"Nachname: {nachname}")
    print(f"Geodaten: {geodaten}")
    print(f"Weitere Daten: {daten}")</code></pre>

  <h3>ğŸ“¥ Aufruf</h3>
  <pre><code>daten_erfassen(
  42,
  "Florian",
  "Daiwig",
  50.123, 8.678,           # Geodaten (args)
  email="florian@beispiel.de",
  beruf="Entwickler"       # keyword-args
)</code></pre>

  <h3>ğŸ›‘ Nicht erlaubt!</h3>
  <p>Folgende Reihenfolge <strong>fÃ¼hrt zu einem Fehler</strong>:</p>
  <pre><code>def falsch(*args, vorname, **kwargs):  # âŒ SyntaxError
    pass</code></pre>

  <h3>ğŸ§  Merksatz:</h3>
  <blockquote>
    Erst <strong>normale Parameter</strong>, dann <code>*args</code>, am Ende <code>**kwargs</code>.
  </blockquote>
</section>
<section id="scoping">
  <h2>ğŸ” Scoping in Python</h2>
  <p>Scoping beschreibt, in welchem Bereich des Codes Variablen sichtbar und nutzbar sind. In Python unterscheidet man zwischen drei Haupt-GÃ¼ltigkeitsbereichen:</p>

  <h3>1. Built-in Scope</h3>
  <ul>
    <li>EnthÃ¤lt alle eingebauten Funktionen und Keywords (z.&nbsp;B. <code>print</code>, <code>len</code>).</li>
    <li>Immer verfÃ¼gbar, ohne Import.</li>
  </ul>

  <h3>2. Global Scope</h3>
  <ul>
    <li>Variablen, die auÃŸerhalb von Funktionen definiert sind.</li>
    <li>Sichtbar im gesamten Code derselben Datei.</li>
    <li>VerÃ¤nderbar in Funktionen nur mit dem <code>global</code>-Keyword.</li>
  </ul>

  <h3>3. Local Scope</h3>
  <ul>
    <li>Variablen, die innerhalb von Funktionen deklariert werden.</li>
    <li>Nur innerhalb dieser Funktion sichtbar.</li>
    <li>Globale Variablen kÃ¶nnen <strong>nicht</strong> direkt Ã¼berschrieben werden.</li>
  </ul>

  <h3>âœ… Beispiel mit <code>global</code>:</h3>
  <pre><code>level = 0

def level_up():
    global level
    level += 1
  </code></pre>

  <p><strong>Merksatz:</strong> Zuerst wird im <em>lokalen Scope</em> gesucht, dann im <em>globalen</em>, zuletzt im <em>built-in Scope</em>.</p>
</section>
<section id="modul-import">
  <h2>ğŸ“¦ Modul entwickeln & einbinden</h2>
  <p>In Python lassen sich eigene Module leicht erstellen und wiederverwenden. Dazu erstellt man eine Datei, z.&nbsp;B. <code>taschenrechner.py</code>, mit Funktionen wie <code>addieren()</code>, <code>subtrahieren()</code> usw.</p>
  <p>Diese kÃ¶nnen dann in einem anderen Script wie <code>main.py</code> Ã¼ber <code>import taschenrechner</code> eingebunden werden. Zugriff auf die Funktionen erfolgt via <code>taschenrechner.addieren(1, 2)</code>.</p>
  <p>Alternativ kann man per <code>from taschenrechner import *</code> alle Funktionen direkt zugÃ¤nglich machen. Achtung bei Namenskonflikten!</p>
  <p>Zur besseren Lesbarkeit empfiehlt sich die Verwendung von Aliasen wie <code>import taschenrechner as tr</code>.</p>
</section>
<section id="if-main">
  <h2>ğŸ§  if <code>__name__ == "__main__"</code> in Python</h2>
  <p>
    Diese Kontrollstruktur sorgt dafÃ¼r, dass bestimmte CodeblÃ¶cke nur ausgefÃ¼hrt werden, wenn das Skript <strong>direkt gestartet</strong> wird â€“ nicht beim Import als Modul.
  </p>
  <pre><code>if __name__ == "__main__":
    # Dieser Code wird nur beim Direktstart ausgefÃ¼hrt
    main()</code></pre>
  <h3>Vorteile:</h3>
  <ul>
    <li>Verhindert unerwÃ¼nschte AusfÃ¼hrung beim Modulimport</li>
    <li>ErmÃ¶glicht TestlÃ¤ufe innerhalb von Modulen</li>
    <li>FÃ¶rdert saubere, modulare Programmstruktur</li>
  </ul>
  <h3>Beispiel:</h3>
  <pre><code># taschenrechner.py
def addiere(a, b):
    return a + b

if __name__ == "__main__":
    print(addiere(1, 2))</code></pre>
</section>
<section id="input-function">
  <h2>ğŸ“¥ input()-Funktion in Python</h2>
  <p>Mit <code>input()</code> lassen sich Benutzereingaben zur Laufzeit abfragen. Die Funktion gibt immer einen <strong>String</strong> zurÃ¼ck.</p>
  
  <h3>ğŸ”¹ Syntax</h3>
  <pre><code>eingabe = input("Bitte gib deinen Namen ein: ")</code></pre>

  <h3>ğŸ”¹ Typumwandlung fÃ¼r Berechnungen</h3>
  <pre><code>geburtsjahr = int(input("In welchem Jahr wurdest du geboren?\n"))
alter = 2023 - geburtsjahr</code></pre>
  <p>Da <code>input()</code> immer einen String liefert, muss eine Umwandlung z.â€¯B. mit <code>int()</code> erfolgen.</p>

  <h3>ğŸ”¹ FehleranfÃ¤lligkeit</h3>
  <p>Gibt der Benutzer z.â€¯B. einen Text statt einer Zahl ein, entsteht ein <code>ValueError</code>. Beispiel:</p>
  <pre><code>ValueError: invalid literal for int() with base 10: 'Florian'</code></pre>

  <h3>ğŸ”¹ Input als Blockierer</h3>
  <pre><code>input("DrÃ¼cke Enter, um das Programm zu beenden.")</code></pre>
  <p>Die AusfÃ¼hrung pausiert, bis eine Eingabe erfolgt â€“ nÃ¼tzlich bei Konsolenfenstern.</p>

  <h3>ğŸ”¹ Gestaltungs-Tipps</h3>
  <ul>
    <li>Nutze <code>\n</code> fÃ¼r ZeilenumbrÃ¼che.</li>
    <li>FÃ¼ge ein Leerzeichen ans Ende der Eingabeaufforderung hinzu, damit der Cursor richtig steht.</li>
  </ul>

  <h3>ğŸ”¹ Beispiel: Altersberechnung</h3>
  <pre><code>jahr = int(input("In welchem Jahr wurdest du geboren?\n"))
alter = 2023 - jahr
print(f"Du bist {alter} Jahre alt.")</code></pre>
</section>
<section id="exec">
  <h2>âš ï¸ Die <code>exec()</code>-Funktion in Python</h2>

  <h3>ğŸ” Was ist <code>exec()</code>?</h3>
  <p>
    Die Funktion <code>exec()</code> fÃ¼hrt Python-Code aus, der als <strong>String</strong> Ã¼bergeben wird. Sie ist Teil der Standardbibliothek und erfordert keinen Import.
  </p>
  <pre><code>exec("print('Hallo Welt')")</code></pre>

  <h3>âš ï¸ Sicherheitsrisiken</h3>
  <ul>
    <li><strong>UngeprÃ¼fte Benutzereingaben</strong> kÃ¶nnen beliebigen Code ausfÃ¼hren.</li>
    <li><strong>Verschleierter Code</strong> (z.â€¯B. Base64) kann Schadcode enthalten.</li>
    <li><strong>Keine EinschrÃ¤nkungen:</strong> Alles im String wird vollstÃ¤ndig ausgefÃ¼hrt.</li>
  </ul>

  <h3>ğŸ”§ Beispiel mit Base64-codiertem Code</h3>
  <pre><code>import base64

code_encoded = "cHJpbnQoIkhlbGxvIFdvcmxkIik="
decoded = base64.b64decode(code_encoded).decode("utf-8")
exec(decoded)  # FÃ¼hrt: print("Hello World") aus</code></pre>

  <h3>ğŸ›¡ï¸ Empfehlungen</h3>
  <ul>
    <li><strong>Vermeide <code>exec()</code></strong>, wenn es nicht zwingend nÃ¶tig ist.</li>
    <li><strong>Nutze Alternativen</strong> wie Funktionen oder sichere <code>eval()</code>-AusdrÃ¼cke.</li>
    <li><strong>Filtere Benutzereingaben</strong> (z.â€¯B. Ã¼ber Whitelisting).</li>
    <li><strong>Analysiere codierten Code</strong> (z.â€¯B. Base64) vor der AusfÃ¼hrung.</li>
  </ul>
</section>
<section>
    <h2>17. Objektorientierte Programmierung (OOP) in Python</h2>
    <ul>
        <li><strong>Klasse</strong> als Vorlage zur Strukturierung von Code â€“ mit Eigenschaften und Methoden.</li>
        <li><code>__init__()</code>: Konstruktor zur Initialisierung von Objekt-Eigenschaften (z.â€¯B. <code>self.name</code>).</li>
        <li><strong>Objekt</strong>: Konkrete Instanz einer Klasse â€“ z.â€¯B. <code>dog1 = Hund("braun", "SchÃ¤ferhund", "Fritzi")</code>.</li>
        <li><code>self</code>: Verweis auf das aktuelle Objekt innerhalb der Klasse.</li>
        <li><strong>Methoden</strong>: Funktionen innerhalb einer Klasse, z.â€¯B. <code>def bellen(self):</code>.</li>
        <li><strong>Vererbung</strong>: Gemeinsame Funktionen und Eigenschaften in einer Oberklasse bÃ¼ndeln.</li>
        <li>Beispiel:
            <pre><code>class Hund(Saeugetier):
    def bellen(self):
        print("Wuff!")</code></pre>
        </li>
        <li>OOP fÃ¶rdert sauberen, wartbaren und wiederverwendbaren Code.</li>
    </ul>
</section>
<section>
    <h2>17. Objektorientierte Programmierung mit Python â€“ PokÃ©mon</h2>
    <h3>Teil 1: Klassen, Attribute und Methoden</h3>
    <ul>
        <li>Mit dem SchlÃ¼sselwort <code>class</code> wird eine Klasse definiert (z.â€¯B. <code>class Pokemon:</code>).</li>
        <li>Die Methode <code>__init__(self, name, level)</code> ist der sogenannte Konstruktor â€“ sie wird beim Erzeugen (Instanziieren) eines Objekts automatisch aufgerufen.</li>
        <li>Innerhalb von <code>__init__</code> werden Objektvariablen definiert, z.â€¯B.:
            <code>self.__name = name</code>, <code>self.__level = level</code>, <code>self.__lebenspunkte = 42</code>.
        </li>
        <li><strong>Objektmethoden</strong> wie <code>vorstellen(self)</code> geben Informationen Ã¼ber das PokÃ©mon aus.</li>
        <li>Die Attribute werden mit <code>self.</code> angesprochen und bleiben dank <code>__</code> geschÃ¼tzt.</li>
        <li>Instanziierung erfolgt durch <code>p1 = Pokemon("Bisasam", 0)</code>.</li>
        <li>Methode <code>get_level()</code> gibt das Level zurÃ¼ck â€“ Zugriff auf geschÃ¼tzte Variablen via Getter-Methoden.</li>
    </ul>

    <h3>Teil 2: Interaktion und Angriffe</h3>
    <ul>
        <li>Neue Methode <code>zeige_level(self)</code> zeigt den Namen + Level kombiniert an.</li>
        <li><code>entwickeln(self)</code> erhÃ¶ht das Level des PokÃ©mon um 1.</li>
        <li>Ein Angriff wird mit <code>attackieren(self, other, schaden)</code> umgesetzt.</li>
        <li>Der Parameter <code>other</code> steht fÃ¼r das PokÃ©mon, das angegriffen wird.</li>
        <li>Beispiel:
            <pre><code>p1.attackieren(p2, 10)</code></pre>
            zieht dem PokÃ©mon <code>p2</code> 10 Lebenspunkte ab.
        </li>
        <li>Die Methode <code>zeige_lebenspunkte()</code> gibt aktuelle HP aus.</li>
        <li>Da der Zugriff innerhalb derselben Klasse erfolgt, kann auch auf <code>__lebenspunkte</code> von <code>other</code> zugegriffen werden.</li>
        <li>Ein vollstÃ¤ndiger Ablauf: PokÃ©mon werden instanziiert, entwickelt, und greifen sich gegenseitig an â€“ und das alles auf Basis von Python OOP.</li>
    </ul>
</section>
<section>
  <h2>18. Magische Methoden in Python â€“ PokÃ©mon</h2>

  <h3>Teil 1: <code>__str__()</code> â€“ Menschlich lesbare Ausgabe</h3>
  <ul>
    <li>Magische Methoden beginnen und enden mit doppelten Unterstrichen (z.â€¯B. <code>__str__</code>).</li>
    <li><code>__str__(self)</code> wird aufgerufen, wenn ein Objekt z.â€¯B. mit <code>print(obj)</code> ausgegeben wird.</li>
    <li>Beispiel-Implementierung fÃ¼r PokÃ©mon:
      <pre><code>def __str__(self):
    return f"Name: {self.__name}\nLebenspunkte: {self.__lebenspunkte}\nLevel: {self.__level}"</code></pre>
    </li>
    <li>Ergebnis: Menschlich lesbare Darstellung wie:
      <pre>Name: Pikachu
Lebenspunkte: 42
Level: 2</pre>
    </li>
  </ul>

  <h3>Teil 2: <code>__gt__()</code> â€“ Vergleichsoperator &gt;</h3>
  <ul>
    <li><code>__gt__(self, other)</code> vergleicht zwei Objekte mit dem GrÃ¶ÃŸer-als-Zeichen.</li>
    <li>Vergleich erfolgt z.â€¯B. anhand des Levels:
      <pre><code>def __gt__(self, other):
    return self.__level > other.__level</code></pre>
    </li>
    <li>Verwendung im Hauptprogramm: <code>if p1 &gt; p2:</code> prÃ¼ft, ob <code>p1</code> ein hÃ¶heres Level hat als <code>p2</code>.</li>
    <li>Ausgabe ist <code>True</code> oder <code>False</code> je nach Vergleich.</li>
  </ul>

  <h3>Weitere wichtige magische Methoden:</h3>
  <ul>
    <li><code>__add__</code> â†’ fÃ¼r <code>+</code> Operator</li>
    <li><code>__sub__</code> â†’ fÃ¼r <code>-</code> Operator</li>
    <li><code>__mul__</code> â†’ fÃ¼r <code>*</code> Operator</li>
    <li><code>__eq__</code> â†’ fÃ¼r <code>==</code> Gleichheit</li>
    <li><code>__lt__</code> â†’ fÃ¼r <code>&lt;</code> Kleiner-als</li>
  </ul>

  <p>ğŸ” Durch magische Methoden wird Python-Code intuitiver und klarer lesbar â€“ besonders bei Klassen wie PokÃ©mon!</p>
</section>
<section>
    <h2>18. Fehlerbehandlung mit <code>try</code> und <code>except</code></h2>
    <ul>
        <li>Mit <code>try</code> wird ein Codeblock getestet, der zu Fehlern fÃ¼hren kann.</li>
        <li>Mit <code>except</code> werden bestimmte Fehler (z.â€¯B. <code>IndexError</code>, <code>ValueError</code>) gezielt abgefangen.</li>
        <li>Syntax:
            <pre><code>try:
    # kritischer Code
except FehlerTyp:
    # Fehlerbehandlung</code></pre>
        </li>
        <li><code>except Exception as ex</code> fÃ¤ngt alle Fehler ab und speichert sie in <code>ex</code>.</li>
        <li>Beispiel:
            <pre><code>try:
    index = int(input("Index: "))
    print(liste[index])
except IndexError:
    print("Index existiert nicht.")
except ValueError:
    print("Bitte Zahl eingeben.")
except Exception as ex:
    print("Fehler:", ex)</code></pre>
        </li>
        <li>ğŸ” Vorteil: Das Programm wird bei Fehlern nicht abgebrochen.</li>
        <li>âš ï¸ Best Practice: MÃ¶glichst gezielte Fehlerbehandlung, kein allgemeiner <code>except</code> im Produktivcode.</li>
    </ul>
</section>
<section>
    <h2>19. <code>finally</code> â€“ Code immer ausfÃ¼hren, egal ob Fehler oder nicht</h2>
    <ul>
        <li><code>finally</code> wird nach allen <code>except</code>-BlÃ¶cken ausgefÃ¼hrt â€“ immer!</li>
        <li>Nutzen: Ressourcen freigeben, Dateien schlieÃŸen, Logs schreiben etc.</li>
        <li>Syntax:
            <pre><code>try:
    # kritischer Code
except Exception:
    # Fehlerbehandlung
finally:
    # wird immer ausgefÃ¼hrt</code></pre>
        </li>
        <li>ğŸ’¡ Typisches Beispiel: Datei schlieÃŸen, egal ob Fehler:
            <pre><code>try:
    f = open("test.txt", "w")
    f.write("Hallo Welt")
except Exception:
    pass
finally:
    f.close()</code></pre>
        </li>
        <li><code>finally</code> ersetzt nicht den <code>except</code> â€“ beide sollten kombiniert werden.</li>
        <li>Empfehlung: In einfachen FÃ¤llen nutze den <code>with</code>-Kontextmanager (z.â€¯B. <code>with open() as f:</code>).</li>
    </ul>
</section>
</body>

</html>