<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Hinweise zu Python</title>
</head>

<body>
    <h1>Hinweise zu Python</h1>

    <section>
        <h2>1. Variablen</h2>
        <ul>
            <li>Variablen speichern Werte. Zuweisung erfolgt mit <code>=</code>.</li>
            <li>Beispiel: <code>name = "Anna"</code> oder <code>age = 25</code>.</li>
            <li>Mehrere Zuweisungen möglich: <code>name, age = "Lisa", 30</code>.</li>
            <li>Werte tauschen: <code>name, age = age, name</code>.</li>
            <li>Variablennamen dürfen nicht mit Zahlen beginnen, keine Sonderzeichen oder Keywords.</li>
            <li>Groß-/Kleinschreibung ist relevant: <code>name ≠ Name</code>.</li>
            <li>Vermeide „Magic Numbers“ – nutze stattdessen Variablen mit Bedeutung.</li>
        </ul>
    </section>

    <section>
        <h2>2. Datentypen</h2>
        <ul>
            <li>Python erkennt Datentypen automatisch (z. B. <code>str</code>, <code>int</code>, <code>float</code>,
                <code>bool</code>).</li>
            <li>Mit <code>type(var)</code> kannst du den Typ prüfen.</li>
            <li>Umwandlungen:
                <ul>
                    <li><code>str(25)</code> → "25"</li>
                    <li><code>int("27")</code> → 27</li>
                    <li><code>float("2.4")</code> → 2.4</li>
                    <li><code>bool("")</code> → False, <code>bool("abc")</code> → True</li>
                </ul>
            </li>
            <li>Fehler bei ungültiger Umwandlung: z. B. <code>int("27 Jahre")</code> → <code>ValueError</code>.</li>
            <li>0, 0.0, "" gelten als <code>False</code>, alle anderen Werte als <code>True</code>.</li>
        </ul>
    </section>

    <section>
        <h2>3. Umgebungsvariablen</h2>
        <ul>
            <li>Systemvariablen wie <code>PATH</code> oder <code>USER</code>.</li>
            <li>Zugriff in Python über <code>os.environ["NAME"]</code>.</li>
            <li><code>python-dotenv</code> ermöglicht das Einlesen einer <code>.env</code>-Datei.</li>
            <li><code>.env</code>-Datei enthält Key-Value-Paare, z. B. <code>USER_NAME=leo</code>.</li>
            <li><code>.env</code> gehört in die <code>.gitignore</code>.</li>
        </ul>
    </section>

    <section>
        <h2>4. Strings definieren</h2>
        <ul>
            <li>Strings mit <code>"Text"</code> oder <code>'Text'</code> definieren.</li>
            <li>Dreifache Anführungszeichen <code>""" """</code> für mehrzeilige Strings.</li>
            <li>Empfehlung:
                <ul>
                    <li>Ein Zeichen: <code>'A'</code></li>
                    <li>Mehrere Zeichen: <code>"Hallo"</code></li>
                    <li>Leerer String: <code>""</code></li>
                </ul>
            </li>
            <li>Mehrzeilige Strings behalten Formatierung – ideal für ASCII-Art oder Konsolenprogramme.</li>
        </ul>
    </section>

    <section>
        <h2>5. Zeichenzugriff & Substrings</h2>
        <ul>
            <li>Zeichenzugriff mit <code>string[index]</code>.</li>
            <li>Index beginnt bei 0: <code>name[2]</code> → drittes Zeichen.</li>
            <li>Negative Indizes zählen von hinten: <code>-1</code> = letztes Zeichen.</li>
            <li><code>len(string)</code> gibt die Länge zurück.</li>
            <li><code>string[len(string)-1]</code> → letztes Zeichen.</li>
            <li>Fehlzugriff außerhalb des Bereichs führt zu <code>IndexError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>6. Slicing</h2>
        <ul>
            <li>Slicing-Syntax: <code>string[start:end]</code> – <code>end</code> ist exklusiv.</li>
            <li><code>string[0:3]</code> → erste 3 Zeichen.</li>
            <li><code>string[:5]</code> → von Anfang bis Index 4.</li>
            <li><code>string[3:]</code> → ab Index 3 bis zum Ende.</li>
            <li><code>string[:]</code> → gesamter String.</li>
            <li>Negative Indizes funktionieren auch: <code>string[-3:-1]</code> → vorletzte 2 Zeichen.</li>
            <li>Start- und Endindex außerhalb der Grenzen sind erlaubt (keine Fehler).</li>
        </ul>
    </section>

    <section>
        <h2>7. Arithmetische Operatoren mit Strings</h2>
        <ul>
            <li><code>+</code> verkettet Strings (z. B. <code>"a" + "b"</code> → "ab").</li>
            <li><code>*</code> dupliziert Strings (z. B. <code>"!" * 3</code> → "!!!").</li>
            <li>Reihenfolge bei <code>*</code> egal: <code>3 * "a" == "a" * 3</code>.</li>
            <li>Nur Kombination <code>String * int</code> ist erlaubt – nicht <code>String * String</code> oder
                <code>String - String</code>.</li>
            <li>Potenzieren mit <code>**</code> sowie Division <code>/</code> ist bei Strings nicht erlaubt.</li>
            <li>Fehlerfälle wie <code>"a" - "b"</code> oder <code>"a" ** 2</code> → <code>TypeError</code>.</li>
        </ul>
    </section>

    <section>
        <h2>8. String-Methoden</h2>
        <ul>
            <li><code>upper()</code>, <code>lower()</code>, <code>capitalize()</code> – Buchstaben umwandeln.</li>
            <li><code>isupper()</code>, <code>islower()</code>, <code>isnumeric()</code>, <code>isalpha()</code> –
                Rückgabe von <code>True</code> oder <code>False</code>.</li>
            <li><code>split(sep)</code>, <code>splitlines()</code> – Zerlegen von Strings in Listen.</li>
            <li><code>strip()</code> – entfernt Leerzeichen am Anfang/Ende.</li>
            <li><code>replace(old, new)</code> – ersetzt Zeichen oder Substrings.</li>
            <li><code>count(sub)</code> – zählt Vorkommen eines Zeichens/Substrings.</li>
            <li><code>index(sub)</code> – Position des ersten Auftretens, Fehler bei Nichtfund.</li>
            <li><code>find(sub)</code> – wie <code>index()</code>, aber ohne Fehler (liefert <code>-1</code>).</li>
            <li><code>"sub" in string</code> – prüft, ob Substring enthalten ist → <code>True</code> oder
                <code>False</code>.</li>
        </ul>
    </section>

    <section>
        <h2>9. Anwendungsbeispiele & Aufgaben zu String-Methoden</h2>
        <ul>
            <li><code>upper()</code> wandelt alle Buchstaben in Großbuchstaben um.</li>
            <li><code>lower()</code> macht alle Buchstaben klein.</li>
            <li><code>capitalize()</code> schreibt nur den ersten Buchstaben groß, Rest klein.</li>
            <li><code>zfill(n)</code> füllt einen String mit führenden Nullen auf Länge <code>n</code> auf.</li>
            <li><code>islower()</code> / <code>isupper()</code> prüfen, ob alle Buchstaben klein/groß sind.</li>
            <li><code>isalpha()</code> prüft, ob nur Buchstaben enthalten sind.</li>
            <li><code>isnumeric()</code> prüft, ob nur Ziffern enthalten sind.</li>
            <li><code>split(";")</code> trennt einen String anhand eines Trennzeichens (liefert Liste).</li>
            <li><code>replace("alt", "neu")</code> ersetzt Teilstrings gezielt.</li>
            <li><code>count("x")</code> zählt Vorkommen eines Zeichens oder Substrings.</li>
            <li><code>find("x")</code> liefert Index oder <code>-1</code>, wenn nicht gefunden.</li>
            <li><code>index("x")</code> wie <code>find</code>, aber mit Fehler bei Nichtfund.</li>
            <li><code>"x" in string</code> prüft, ob <code>x</code> im String enthalten ist.</li>
            <li><code>string[::-1]</code> kehrt einen String um (Reversal per Slicing).</li>
        </ul>
    </section>

    <!-- Arithmetische Operatoren in Python -->
    <section id="arithmetische-operatoren">
        <h2>🧮 Arithmetische Operatoren in Python</h2>
        <p>Hier siehst du eine Übersicht typischer Rechenoperationen und deren Verhalten in Python:</p>

        <h3>1. Grundrechenarten</h3>
        <ul>
            <li><code>12 * 12</code> → <strong>144</strong></li>
            <li><code>2.5 + 3.5</code> → <strong>6.0</strong> (Float + Float = Float)</li>
            <li><code>20 / 5</code> → <strong>4.0</strong> (Division liefert immer Float)</li>
            <li><code>15 - 3 * 5</code> → <strong>0</strong> (Punktrechnung vor Strichrechnung)</li>
        </ul>

        <h3>2. Integer Division <code>//</code></h3>
        <ul>
            <li><code>8 + 10 // 4</code> → <strong>10</strong></li>
            <li><code>8 + 10 / 4</code> → <strong>10.5</strong></li>
            <li><code>20 / (5 - 4)</code> → <strong>20.0</strong></li>
        </ul>

        <h3>3. Kombinationen & Reihenfolge</h3>
        <ul>
            <li><code>4 * 2.5 / 4</code> → <strong>2.5</strong> (Links-nach-rechts-Auswertung)</li>
            <li><code>1 // 2 - 3 // 4</code> → <strong>0</strong></li>
        </ul>

        <h3>4. Modulo <code>%</code></h3>
        <ul>
            <li><code>12 % 5</code> → <strong>2</strong></li>
            <li><code>5 % 12</code> → <strong>5</strong></li>
        </ul>

        <h3>5. Potenzen <code>**</code></h3>
        <ul>
            <li><code>2 ** 3</code> → <strong>8</strong></li>
            <li><code>4 ** (8 - 5)</code> → <strong>64</strong></li>
            <li><code>2 ** 8 // 2</code> → <strong>128</strong></li>
            <li><code>5 ** 2 * 3</code> → <strong>75</strong></li>
        </ul>

        <h3>6. String-Operationen</h3>
        <ul>
            <li><code>"Apfel" + "Baum"</code> → <strong>"ApfelBaum"</strong></li>
            <li><code>5 * ("a" + "b")</code> → <strong>"ababababab"</strong></li>
            <li><code>"x" * 2 ** 3</code> → <strong>"xxxxxxxx"</strong></li>
        </ul>

        <h3>7. Sonderfälle</h3>
        <ul>
            <li><code>42 % 43</code> → <strong>42</strong></li>
            <li><code>1024 % 2</code> → <strong>0</strong></li>
            <li><code>5 * 4 * 3 * 2 * 1.0</code> → <strong>120.0</strong></li>
            <li><code>0 * "Flo"</code> → <strong>""</strong> (leerer String)</li>
            <li><code>"XYZ" * (12 % 5)</code> → <strong>"XYZXYZ"</strong></li>
        </ul>
    </section>

    <section>
        <h2>11. Inkrementieren, Dekrementieren & Kurzschreibweisen</h2>
        <ul>
            <li>Python kennt keine <code>i++</code> oder <code>i--</code> Operatoren wie in C/Java.</li>
            <li>Stattdessen: kombinierte Zuweisungsoperatoren verwenden.</li>
            <li>Beispiele:
                <ul>
                    <li><code>i += 1</code> → Erhöhe <code>i</code> um 1</li>
                    <li><code>i -= 1</code> → Verringere <code>i</code> um 1</li>
                    <li><code>i *= 2</code> → Multipliziere <code>i</code> mit 2</li>
                    <li><code>i /= 2</code> → Division mit float-Ergebnis</li>
                    <li><code>i //= 2</code> → Ganzzahldivision (Integer)</li>
                    <li><code>i **= 2</code> → Quadrat von <code>i</code></li>
                    <li><code>i %= 3</code> → Rest bei Division durch 3</li>
                </ul>
            </li>
            <li>Die Kurzform spart Wiederholung der Variable und verbessert Lesbarkeit.</li>
        </ul>
    </section>
    <section>
        <h2>12. Vergleichsoperatoren</h2>
        <ul>
            <li>Vergleichsoperatoren geben immer <code>True</code> oder <code>False</code> zurück.</li>
            <li>Verfügbare Operatoren:
                <ul>
                    <li><code>a < b</code> → kleiner als</li>
                    <li><code>a <= b</code> → kleiner oder gleich</li>
                    <li><code>a == b</code> → gleich</li>
                    <li><code>a != b</code> → ungleich</li>
                    <li><code>a > b</code> → größer als</li>
                    <li><code>a >= b</code> → größer oder gleich</li>
                </ul>
            </li>
            <li>Funktioniert mit Zahlen, Strings (alphabetisch) und später auch mit Objekten.</li>
            <li>Beispiel:
                <code>"Flo" < "Florian"</code> → <code>True</code> (wegen alphabetischer Ordnung)
            </li>
            <li>Alle Vergleichsoperatoren haben die gleiche Bindungsstärke und werden von links nach rechts ausgewertet.
            </li>
        </ul>
    </section>

    <section>
        <h2>13. Logische Operatoren</h2>
        <ul>
            <li>Verknüpfen Wahrheitswerte (<code>True</code> oder <code>False</code>).</li>
            <li>Ergebnisse sind stets <code>True</code> oder <code>False</code>.</li>
            <li>Operatoren:
                <ul>
                    <li><code>and</code> → nur <code>True</code>, wenn beide Bedingungen <code>True</code> sind.</li>
                    <li><code>or</code> → <code>True</code>, wenn mindestens eine Bedingung <code>True</code> ist.</li>
                    <li><code>not</code> → kehrt den Wahrheitswert um.</li>
                    <li><code>^</code> (XOR) → <code>True</code>, wenn genau eine Bedingung <code>True</code> ist.</li>
                </ul>
            </li>
            <li>Beispiele:
                <ul>
                    <li><code>2 &lt; 3 and 3 &lt; 5</code> → <code>True</code></li>
                    <li><code>not (3 == 5)</code> → <code>True</code></li>
                    <li><code>True ^ False</code> → <code>True</code></li>
                </ul>
            </li>
            <li>Operatorrangfolge:
                <ul>
                    <li><strong>1.</strong> <code>not</code></li>
                    <li><strong>2.</strong> <code>and</code></li>
                    <li><strong>3.</strong> <code>or</code></li>
                </ul>
            </li>
            <li>Nutze <code>()</code>, um Auswertungsreihenfolge gezielt zu steuern.</li>
        </ul>
    </section>

    <section>
        <h2>14. Logik-Aufgaben & Kombinationen</h2>
        <ul>
            <li><strong>Operatoren:</strong> <code>and</code>, <code>or</code>, <code>not</code>, <code>^</code> (XOR).
            </li>
            <li><strong>Ergebnisse:</strong> Immer <code>True</code> oder <code>False</code>.</li>
            <li><strong>Operatorrangfolge:</strong>
                <ul>
                    <li><code>not</code> bindet am stärksten</li>
                    <li><code>and</code> folgt</li>
                    <li><code>or</code> danach</li>
                    <li><code>^</code> (XOR) ist ein bitweiser Operator mit hoher Bindung</li>
                </ul>
            </li>
            <li><strong>Verwendung in Bedingungen:</strong> Vergleichs- und arithmetische Operatoren werden zuerst
                ausgewertet, danach logische Operatoren.</li>
            <li><strong>Beispiele:</strong>
                <ul>
                    <li><code>True and False or True</code> → <code>True</code></li>
                    <li><code>not False</code> → <code>True</code></li>
                    <li><code>True ^ True</code> → <code>False</code></li>
                    <li><code>2 % 5 == 2</code> → <code>True</code></li>
                    <li><code>not not not (2 % 5 == 2)</code> → <code>False</code></li>
                </ul>
            </li>
            <li><strong>Unterschied:</strong>
                <ul>
                    <li><code>or</code>: beides darf <code>True</code> sein (z. B. „Milch oder Zucker“)</li>
                    <li><code>^</code>: nur eins darf <code>True</code> sein („entweder Big Mac oder Big Tasty“)</li>
                </ul>
            </li>
            <li><strong>Mix mit Zahlen:</strong> <code>True ^ 0</code> ergibt <code>1</code> (kein Boolean, sondern
                Integer!)</li>
        </ul>
    </section>

    <section>
        <h2>15. Operatorrangfolge</h2>
        <p>Die folgende Tabelle zeigt die Reihenfolge, in der Operatoren in Python ausgewertet werden (von oben nach
            unten – höchste zu niedrigster Bindung):</p>
        <table border="1" cellpadding="6" cellspacing="0">
            <thead>
                <tr>
                    <th>Priorität</th>
                    <th>Operator(en)</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td><code>**</code></td>
                    <td>Potenz (Exponentiation)</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
                    <td>Multiplikation, Division, ganzzahlige Division, Modulo</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><code>+</code>, <code>-</code></td>
                    <td>Addition, Subtraktion</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td><code>^</code></td>
                    <td>Bitweises XOR (zählt technisch zu bitweisen Operatoren)</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>,
                        <code>&gt;</code></td>
                    <td>Vergleichsoperatoren</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td><code>not</code></td>
                    <td>Logische Negation</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td><code>and</code></td>
                    <td>Logisches UND</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td><code>or</code></td>
                    <td>Logisches ODER (schwächste Bindung)</td>
                </tr>
            </tbody>
        </table>
        <p>Tipp: Wenn du eine andere Reihenfolge erzwingen willst, nutze Klammern <code>()</code>.</p>
    </section>
    <section>
        <h2>11. If-Anweisung</h2>
        <ul>
            <li><code>if</code> prüft eine Bedingung und führt Code nur aus, wenn sie <code>True</code> ergibt.</li>
            <li>Syntax:
                <pre><code>if BEDINGUNG:
    # tue etwas
else:
    # tue etwas anderes</code></pre>
            </li>
            <li>Vergleich mit <code>==</code>, nicht mit <code>=</code> (Zuweisung!).</li>
            <li>Einrückung nach dem <code>:</code> ist zwingend (meist 4 Leerzeichen).</li>
            <li><code>else</code> ist optional, darf aber nur mit passendem <code>if</code> verwendet werden.</li>
            <li>Beispiel:
                <pre><code>passwort = input("Gib dein Passwort ein:")
if passwort == "ABC123":
    print("Das Passwort ist korrekt.")
else:
    print("Das Passwort ist nicht korrekt.")</code></pre>
            </li>
        </ul>
    </section>
    <section>
    <h2>12. Mehrfache Bedingungen mit <code>elif</code></h2>
    <ul>
        <li><code>elif</code> steht für „else if“ – wird geprüft, wenn die <code>if</code>-Bedingung nicht zutrifft.</li>
        <li><code>else</code> fängt alle übrigen Fälle auf, wenn keine vorherige Bedingung zutrifft.</li>
        <li>Nur der erste passende Block wird ausgeführt – danach wird der Rest ignoriert.</li>
        <li>Syntax:
            <pre><code>if BEDINGUNG:
    ANWEISUNG
elif ANDERE_BEDINGUNG:
    ANWEISUNG
else:
    ANWEISUNG</code></pre>
        </li>
        <li>Beispiel:
            <pre><code>note = input("Gib die Schulnote ein (1–6): ")

if note == "1":
    print("Sehr gut!")
elif note == "2":
    print("Gut")
elif note == "3":
    print("Befriedigend")
elif note == "4":
    print("Ausreichend")
elif note == "5":
    print("Mangelhaft")
elif note == "6":
    print("Ungenügend")
else:
    print("Ungültige Eingabe")</code></pre>
        </li>
        <li>Tipp: Für numerische Eingaben <code>int()</code> verwenden:
            <pre><code>note = int(input("Gib die Schulnote als Zahl ein: "))</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>10. Match-Case (ab Python 3.10)</h2>
    <ul>
        <li><code>match</code> prüft den Wert einer Variable gegen mehrere <code>case</code>-Fälle.</li>
        <li>Ähnlich wie <code>switch-case</code> in anderen Sprachen, aber leistungsfähiger.</li>
        <li><code>case _</code> entspricht einem <code>else</code>-Zweig – wird ausgeführt, wenn kein anderer <code>case</code> passt.</li>
        <li>Beispiel mit Strings:
            <pre><code>match note:
    case "1":
        print("Sehr gut!")
    case "2":
        print("Gut")
    case _:
        print("Ungültige Eingabe.")</code></pre>
        </li>
        <li>Auch mit <code>int</code> möglich – z. B. <code>match int(note):</code></li>
        <li>Erweiterbar auf Listen, Tupel oder eigene Objekte (Pattern Matching).</li>
    </ul>
</section>

<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen Codeblöcke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird – sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>11. While-Schleifen</h2>
    <ul>
        <li>Wiederholen Codeblöcke, solange eine Bedingung <code>True</code> ergibt.</li>
        <li><strong>Syntax:</strong><br>
            <code>while BEDINGUNG:</code><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<code>ANWEISUNG</code>
        </li>
        <li>Bedingung muss zu einem booleschen Wert (<code>True</code> / <code>False</code>) evaluiert werden.</li>
        <li>Wird die Bedingung <code>False</code>, endet die Schleife.</li>
        <li>Beispiel:
            <pre><code>x = 5
runde = 1
while x > 0:
    print(f"Runde {runde}")
    runde += 1
    x -= 1</code></pre>
        </li>
        <li><strong>Nutzereingaben mit while:</strong><br>
            <pre><code>namen = []
name = input("Name eingeben (X zum Beenden): ")
while name != "X":
    namen.append(name)
    print(namen)
    name = input("Name eingeben (X zum Beenden): ")</code></pre>
        </li>
        <li>Achte darauf, dass die Bedingung irgendwann <code>False</code> wird – sonst entsteht eine Endlosschleife.</li>
    </ul>
</section>
<section>
    <h2>12. For-Schleifen</h2>
    <ul>
        <li>Eine <code>for</code>-Schleife wird verwendet, um eine definierte Anzahl an Durchläufen über eine Datenstruktur (z. B. Liste, Tupel, <code>range()</code>) durchzuführen.</li>
        <li><code>for element in iterable:</code> → Jeder Eintrag wird nacheinander der Variablen zugewiesen.</li>
        <li>Beispiel:
            <pre><code>passwoerter = ["abc123", "geheim", "test", "123456"]
for passwort in passwoerter:
    print(passwort)</code></pre>
        </li>
        <li><code>break</code> bricht die Schleife vorzeitig ab, z. B. bei einer Abbruchbedingung:
            <pre><code>if len(passwort) &lt; 5:
    break</code></pre>
        </li>
        <li>Funktioniert mit Listen, Tupeln, Sets, Dictionaries, Strings & <code>range()</code>.</li>
        <li>Besonders leserlich durch Python's iterator-basierten Ansatz.</li>
    </ul>
</section>
<section>
    <h2>13. Endlosschleifen</h2>
    <p>Endlosschleifen entstehen, wenn eine <code>while</code>-Schleife nie endet, weil ihre Bedingung dauerhaft <code>True</code> bleibt.</p>
    <p>Beispiel einer fehlerhaften <code>while</code>-Schleife:</p>
    <pre><code>teilnehmer = input("Teilnehmer eingeben: ")
teilnehmer_liste = []

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    # Eingabe fehlt hier → Endlosschleife</code></pre>
    <p><strong>Richtig:</strong> Eingabe innerhalb der Schleife erneut abfragen:</p>
    <pre><code>teilnehmer_liste = []
teilnehmer = input("Teilnehmer eingeben (X zum Beenden): ")

while teilnehmer != "X":
    teilnehmer_liste.append(teilnehmer)
    print(teilnehmer_liste)
    teilnehmer = input("Nächster Teilnehmer (X zum Beenden): ")</code></pre>
    <p>Alternativ mit <code>while True</code> und <code>break</code> absichern:</p>
    <pre><code>i = 0
while True:
    if i == 3:
        break
    print("Durchlauf", i)
    i += 1</code></pre>
    <p>💡 Achte darauf, dass sich die Bedingung in der Schleife irgendwann ändert – sonst läuft sie unendlich weiter.</p>
</section>

<section>
  <h2>14. Unterschied: for vs. while</h2>
  <p>🔁 Python kennt zwei Haupt-Schleifentypen:</p>
  <ul>
    <li><strong><code>for</code>-Schleife:</strong> Wiederholt einen Codeblock <em>eine festgelegte Anzahl an Malen</em> – typischerweise über Datenstrukturen wie Listen, Tupel oder Strings.</li>
    <li><strong><code>while</code>-Schleife:</strong> Wiederholt den Codeblock <em>solange eine Bedingung wahr ist</em> – die Laufzeit ist also abhängig von Benutzeraktionen oder Programmlogik.</li>
  </ul>

  <h3>🧠 Vergleich</h3>
  <table>
    <thead>
      <tr>
        <th>Eigenschaft</th>
        <th><code>for</code>-Schleife</th>
        <th><code>while</code>-Schleife</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>⏳ Laufzeit</td>
        <td>Vordefiniert (z.&nbsp;B. durch Länge einer Liste)</td>
        <td>Abhängig von einer Bedingung</td>
      </tr>
      <tr>
        <td>📦 Typischer Einsatz</td>
        <td>Datenstrukturen durchlaufen</td>
        <td>Benutzereingaben, Event Loops, Server-Überwachung</td>
      </tr>
      <tr>
        <td>❌ Endlosschleifen möglich?</td>
        <td>Nein (endet automatisch nach X Durchläufen)</td>
        <td>Ja (z.&nbsp;B. durch <code>while True</code>)</td>
      </tr>
      <tr>
        <td>🔧 Benutzerabbruch</td>
        <td>Nur mit <code>break</code> bei zusätzlicher Prüfung</td>
        <td>Einfach durch Eingabebedingung steuerbar</td>
      </tr>
    </tbody>
  </table>

  <p>💡 <strong>Fazit:</strong> Verwende <code>for</code>, wenn die Anzahl der Durchläufe bekannt ist (z.&nbsp;B. Liste, String, range), und <code>while</code>, wenn du flexibel auf Bedingungen oder Benutzereingaben reagieren musst.</p>
</section>
<section>
  <h2>15. Walross-Operator <code>:=</code></h2>
  <p>
    Seit Python 3.8 gibt es den sogenannten <strong>Walross-Operator</strong> <code>:=</code> (auch „<em>assignment expression</em>“ genannt).
    Er erlaubt, einer Variablen innerhalb einer Bedingung <em>einen Wert zuzuweisen und diesen gleichzeitig zu prüfen</em> – ideal für kompakte, lesbare Schleifen.
  </p>

  <h3>📚 Beispiel: Teilnehmerliste mit <code>while</code>-Schleife</h3>
  <pre><code>teilnehmerliste = []

while (teilnehmer := input("Gib einen Teilnehmer ein: ")) != "x":
    teilnehmerliste.append(teilnehmer)

print("Teilnehmerliste:", teilnehmerliste)</code></pre>

  <h3>🧠 Vorteile:</h3>
  <ul>
    <li>Vermeidet doppelte Codezeilen wie <code>input(...)</code> vor und in der Schleife.</li>
    <li>Erhöht die Lesbarkeit & reduziert Fehler durch Copy-Paste.</li>
    <li>Perfekt für kompakte while-Bedingungen mit Zuweisung.</li>
  </ul>

  <p>💡 Merkhilfe: Der Operator <code>:=</code> sieht aus wie das Gesicht eines 🦭 Walrosses – daher der Name.</p>
</section>
<section>
  <h2>16. Listen in Python</h2>
  <ul>
    <li>Listen sind <strong>flexibel</strong> und <strong>dynamisch</strong>: Sie können verschiedene Datentypen enthalten (z. B. <code>int</code>, <code>str</code>, <code>bool</code>).</li>
    <li>Erstellung: <code>liste = []</code> (leere Liste) oder z. B. <code>liste = [42, "Florian", True]</code></li>
    <li>Länge ermitteln mit <code>len(liste)</code></li>
    <li>Zugriff über Index: <code>liste[0]</code>, <code>liste[-1]</code> (letztes Element)</li>
    <li><strong>Slicing</strong>: <code>liste[1:4]</code> – liefert eine Teilliste (Start inkl., Ende exkl.)</li>
    <li>Out-of-Range beim <strong>Slicing</strong> ist erlaubt → kein Fehler.</li>
    <li>Out-of-Range bei direktem Indexzugriff (<code>liste[99]</code>) führt zu <code>IndexError</code>.</li>
  </ul>
</section>
<section>
  <h2>Kapitel 17 – Listenmethoden</h2>
  <p>Listen sind dynamische Datenstrukturen in Python, die Elemente verschiedenster Typen aufnehmen können. Sie bieten eine Vielzahl an Methoden zur Bearbeitung.</p>

  <h3>Elemente hinzufügen</h3>
  <ul>
    <li><code>+</code> zum Verketten von Listen</li>
    <li><code>*</code> zur Wiederholung von Listen</li>
    <li><code>.append(wert)</code> – Hängt ein einzelnes Element an</li>
    <li><code>.insert(index, wert)</code> – Fügt ein Element an gegebener Position ein</li>
  </ul>

  <h3>Elemente entfernen</h3>
  <ul>
    <li><code>.remove(wert)</code> – Entfernt das erste Vorkommen</li>
    <li><code>.clear()</code> – Leert die gesamte Liste</li>
  </ul>

  <h3>Weitere Methoden</h3>
  <ul>
    <li><code>.count(wert)</code> – Zählt, wie oft ein Wert vorkommt</li>
    <li><code>.sort()</code> – Sortiert die Liste (optional: <code>reverse=True</code>)</li>
    <li><code>.copy()</code> – Erstellt eine echte Kopie</li>
    <li><code>.index(wert)</code> – Gibt die erste Indexposition eines Werts zurück</li>
    <li><code>w in liste</code> – Prüft, ob <code>w</code> enthalten ist</li>
  </ul>

  <h3>String-Methode <code>.join()</code></h3>
  <p>Wird auf einen String angewendet und verbindet die Elemente einer String-Liste:</p>
  <pre><code>'-'.join(["A", "B", "C"])  # "A-B-C"</code></pre>
</section>
<!-- Tupel in Python -->
<section id="tupel-python">
  <h2>📘 Tupel in Python</h2>
  <p>Tupel sind eine unveränderliche Datenstruktur in Python, ähnlich wie Listen, aber starr.</p>

  <h3>🧩 Eigenschaften</h3>
  <ul>
    <li>Unveränderlich: keine Elemente hinzufügen, löschen oder ändern</li>
    <li>Festgelegte Länge und Reihenfolge</li>
    <li>Ideal für konstante Werte wie Koordinaten oder Funktionsrückgaben</li>
  </ul>

  <h3>🧪 Syntax</h3>
  <pre><code>mein_tupel = (1, 2, 3)
leeres_tupel = ()
</code></pre>

  <h3>📏 Länge bestimmen</h3>
  <pre><code>len((1, 2, 3))  # → 3</code></pre>

  <h3>🎯 Zugriff auf Elemente</h3>
  <pre><code>t = (4, 5, 29, 7)
t[2]    # → 29
t[-2]   # → 29 (von hinten)</code></pre>

  <h3>🔁 Direktzugriff ohne Variable</h3>
  <pre><code>print((4, 5, 29, 7)[-2])  # → 29</code></pre>

  <h3>⚙️ Tupel als Rückgabe von Funktionen</h3>
  <pre><code>def addieren(a, b):
    return a, b, a + b

ergebnis = addieren(1, 4)
print(ergebnis)        # → (1, 4, 5)
print(type(ergebnis))  # → &lt;class 'tuple'&gt;</code></pre>

  <h3>🧠 *args → automatisch Tupel</h3>
  <pre><code>def addieren(*summanden):
    print(type(summanden))  # → &lt;class 'tuple'&gt;
    return sum(summanden)

addieren(1, 2, 3)  # → 6</code></pre>

  <h3>📌 Merksatz</h3>
  <blockquote>
    Tupel = Liste, die man nicht verändern darf.
  </blockquote>
</section>


</body>

</html>